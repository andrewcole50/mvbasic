{
	"d3": {
		"$chain": {
			"prefix": "$chain",
			"body": "$chain $fileref $itemid",
			"description": "The $chain statement continues FlashBASIC or BASIC compilation in a different source item."
		},
		"$include": {
			"prefix": "$include",
			"body": "$include $fileref $itemid",
			"description": "The $include statement inserts FlashBASIC or BASIC code from a separate item (known as an include item) to be compiled as part of the object module of the current program or subroutine. The original source program is not altered."
		},
		"$options": {
			"prefix": "$options",
			"body": "$options $tag",
			"description": "The $options statement sets compatibility options for the FlashBASIC or BASIC compiler."
		},
		"BREAK OFF": {
			"prefix": "BREAK",
			"body": "BREAK OFF",
			"description": "The break statement enables or disables the BREAK key."
		},
		"BREAK ON": {
			"prefix": "BREAK",
			"body": "BREAK ON",
			"description": "The break statement enables or disables the BREAK key."
		},
		"COM": {
			"prefix": "COM",
			"body": "COM $1",
			"description": "The common statement declares data elements to share among different FlashBASIC or BASIC modules."
		},
		"COMPARE All": {
			"prefix": "COMPARE",
			"body": "COMPARE $str1 TO $str2 PRESENT $exist MISSING $missing",
			"description": "The compare statement compares two dynamic arrays."
		},
		"CONVERT Function": {
			"prefix": "CONVERT",
			"body": "CONVERT($var, $str1, $str2)",
			"description": "The convert() function searches a given variable and replaces each occurrence of a character by another."
		},
		"CRT @": {
			"prefix": "CRT",
			"body": "CRT @($col, $row):$expr",
			"description": "The crt statement outputs unconditionally to the terminal display, regardless of whether or not the printer on condition is in effect."
		},
		"DISPLAY": {
			"prefix": "DISPLAY",
			"body": "DISPLAY $expr",
			"description": "The crt statement outputs unconditionally to the terminal display, regardless of whether or not the printer on condition is in effect."
		},
		"DISPLAY @": {
			"prefix": "DISPLAY",
			"body": "DISPLAY @($col, $row):$expr",
			"description": "The crt statement outputs unconditionally to the terminal display, regardless of whether or not the printer on condition is in effect."
		},
		"DEL Attribute": {
			"prefix": "DEL",
			"body": "DEL $variable<$attr>",
			"description": "The del statement provides an alternate to the delete() function for deleting a location from a dynamic array."
		},
		"DEL SubValue": {
			"prefix": "DEL",
			"body": "DEL $variable<$attr, $value, $subValue>",
			"description": "The del statement provides an alternate to the delete() function for deleting a location from a dynamic array."
		},
		"DEL Value": {
			"prefix": "DEL",
			"body": "DEL $variable<$attr, $value>",
			"description": "The del statement provides an alternate to the delete() function for deleting a location from a dynamic array."
		},
		"DELETE Function": {
			"prefix": "DELETE",
			"body": "DELETE($dynarr, $attr, $val, $subval)",
			"description": "The delete() function removes a specific attribute, value, or subvalue from a dimensioned or dynamic array."
		},
		"DELETE All": {
			"prefix": "DELETE",
			"body": "DELETE $filevar,$recordkey ON ERROR $statements",
			"description": "The delete statement removes a specific item from a file."
		},
		"EQU": {
			"prefix": "EQU",
			"body": "EQU $symbol TO $var",
			"description": "The equate statement is a compiler directive that declares a constant at compile time or a synonym of another variable or array element."
		},
		"ERROR Function": {
			"prefix": "ERROR",
			"body": "ERROR()",
			"description": "The error() function retrieves the TCL command used to activate the program and loads it into a specified variable."
		},
		"ERROR Statement": {
			"prefix": "ERROR",
			"body": "ERROR $messagenum, $params",
			"description": "The error statement displays the error message from the messages file and continues execution of the program."
		},
		"EXECUTE All": {
			"prefix": "EXECUTE",
			"body": "EXECUTE $expr CAPTURING $var RETURNING $statusvar",
			"description": "The execute statement temporarily pushes a level and performs any valid TCL expression, then continues execution of the FlashBASIC or BASIC program."
		},
		"EXTRACT SubValue": {
			"prefix": "EXTRACT",
			"body": "EXTRACT($DynArr, $attr, $value, $subvalue)",
			"description": "The extract() function retrieves a specific attribute, value, or subvalue from a dimensioned or dynamic array."
		},
		"EXTRACT Value": {
			"prefix": "EXTRACT",
			"body": "EXTRACT($DynArr, $attr, $value)",
			"description": "The extract() function retrieves a specific attribute, value, or subvalue from a dimensioned or dynamic array."
		},
		"FIELD Extract Count": {
			"prefix": "FIELD",
			"body": "FIELD($string, $delimiter, $occurrence, $extractCount)",
			"description": "The field() function returns a substring from a string expression, by specifying a delimiter and the desired occurrence."
		},
		"FOR Loop": {
			"prefix": "FOR",
			"body": [
				"FOR $1 = $2 TO $3",
				"$4",
				"NEXT $1"
			],
			"description": "The for...next statement is an iterative, incremental loop statement used to repeat a sequence of statements for a specific number of occurrences."
		},
		"FOR Step": {
			"prefix": "FOR",
			"body": [
				"FOR $1 = $2 TO $3 STEP $4",
				"$5",
				"NEXT $1"
			],
			"description": "The for...next statement is an iterative, incremental loop statement used to repeat a sequence of statements for a specific number of occurrences."
		},
		"IF Then": {
			"prefix": "IF",
			"body": [
				"IF $1 THEN",
				"\t$2",
				"END"
			],
			"description": "The if statement tests the result of a logical expression. Depending on whether the expression evaluates to either true or false, the statements following the then or else clauses respectively are executed."
		},
		"IF Then\/Else": {
			"prefix": "IF",
			"body": [
				"IF $1 THEN",
				"\t$2",
				"END ELSE",
				"\t$3",
				"END"
			],
			"description": "The if statement tests the result of a logical expression. Depending on whether the expression evaluates to either true or false, the statements following the then or else clauses respectively are executed."
		},
		"IN For": {
			"prefix": "IN",
			"body": [
				"IN $var FOR $deciseconds THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": ""
		},
		"INPUT @": {
			"prefix": "INPUT",
			"body": "INPUT @($col, $row): $var",
			"description": "The input statement temporarily suspends execution of the program until a response is provided from the keyboard and assigns that response to a specified variable."
		},
		"INPUT All": {
			"prefix": "INPUT",
			"body": [
				"INPUT $var , $length, $fill $modes THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The input statement temporarily suspends execution of the program until a response is provided from the keyboard and assigns that response to a specified variable."
		},
		"INPUTTRAP GOSUB": {
			"prefix": "INPUTTRAP",
			"body": "INPUTTRAP $str GOSUB $statementlabel",
			"description": "The inputtrap...gosub statement, using the str.exp, sets up an automatic computed gosub based on the next input @ statement data. The position of the character in the string expression corresponds to the position of the statement label in the list. This acts as a trap that causes a gosub on all subsequent input @ statements."
		},
		"LOCATE Function": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE($str, $dynarr, $attr, $value; $returnVar) THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The locate statement searches for the location of a specific string expression and returns the location in position.var."
		},
		"LOCATE Function Order By": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE($str, $dynarr, $attr, $value, $start; $returnVar; $orderBy) THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": ""
		},
		"LOCATE Order By": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE $search IN $subject BY $orderBy SETTING $returnVar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The locate statement searches for the location of a specific string expression and returns the location in position.var."
		},
		"LOOP Until": {
			"prefix": "LOOP",
			"body": [
				"LOOP",
				"\t$statement1",
				"UNTIL $expr DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The loop statement repetitively executes (loops) until an ending condition is met. The first set of statements, if present, is executed at least once."
		},
		"LOOP While": {
			"prefix": "LOOP",
			"body": [
				"LOOP",
				"\t$statement1",
				"WHILE $expr DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The loop statement repetitively executes (loops) until an ending condition is met. The first set of statements, if present, is executed at least once."
		},
		"MATBUILD Using": {
			"prefix": "MATBUILD",
			"body": "MATBUILD $variable FROM $array, $startexpr, $endexpr USING $delimiter",
			"description": "The matbuild statement converts a dimensioned array into a dynamic array."
		},
		"MATPARSE Using": {
			"prefix": "MATPARSE",
			"body": "MATPARSE $mat FROM $str USING $delim SETTING $var",
			"description": "The matparse statement converts a dynamic array into a dimensioned array."
		},
		"MATREAD All": {
			"prefix": "MATREAD",
			"body": [
				"MATREAD $mat FROM $filevar, $recordkey LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The matread statement reads the specified item from the optionally specified file.var, or if not specified, the default file.var, and stores one attribute per element in the dimensioned array."
		},
		"MATREADU All": {
			"prefix": "MATREADU",
			"body": [
				"MATREADU $mat FROM $filevar, $recordkey LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The matreadu form of the matread statement tests if an item is already locked and locks the item if it is not. The item lock set by matreadu prevents the item from being read using the matreadu statement or updated by other processes while the lock is set."
		},
		"OPEN All": {
			"prefix": "OPEN",
			"body": [
				"OPEN $filename TO $filevar ON ERROR $err_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The open statement opens a specified file name and associates the file with the optional file.var."
		},
		"READNEXT All": {
			"prefix": "READNEXT",
			"body": [
				"READNEXT $var, $valpos, $subvalpos FROM $list THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The readnext statement retrieves the next item-ID from an active list and assigns it to a specified variable."
		},
		"READU": {
			"prefix": "READU",
			"body": [
				"READU $var FROM $filevar,$recordkey THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The readu statement reads an item as a dynamic array, locks it, and stores the item as a string. Each attribute is automatically an element of the dynamic array variable and can be referenced with the appropriate intrinsic functions."
		},
		"READU Locked": {
			"prefix": "READU",
			"body": [
				"READU $var FROM $filevar,$recordkey LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The readu statement reads an item as a dynamic array, locks it, and stores the item as a string. Each attribute is automatically an element of the dynamic array variable and can be referenced with the appropriate intrinsic functions."
		},
		"READVU": {
			"prefix": "READVU",
			"body": [
				"READVU $var FROM $filevar,$recordkey,$attr THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The readvu statement reads an item from the optionally-specified file variable, locks it, and assigns the value contained in the attribute number referenced in the attribute expression to the specified variable."
		},
		"READVU All": {
			"prefix": "READVU",
			"body": [
				"READVU $var FROM $filevar,$recordkey,$attr LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The readv statement reads an item from the optionally-specified file variable, locks it, and assigns the value contained in the attribute number referenced in the attribute expression to the specified variable."
		},
		"REM Comment": {
			"prefix": "REM",
			"body": "REM $text",
			"description": "The REM statement is used as a remark. Text after this statement is ignored."
		},
		"REMOVE Statement": {
			"prefix": "REMOVE",
			"body": "REMOVE $str FROM $array AT $pos SETTING $setvar",
			"description": "The remove statement retrieves a substring delimited by a system delimiter from a dynamic array."
		},
		"REPLACE Function": {
			"prefix": "REPLACE",
			"body": "REPLACE($dynarr, $attr, $value, $subvalue; $replace)",
			"description": "The replace() function inserts or replaces a specific attribute, value, or subvalue in the string referenced by dyn.array.exp with the value referenced in str.exp."
		},
		"REPLACE Statement": {
			"prefix": "REPLACE",
			"body": "REPLACE $filevar, $itemid_old WITH $itemid_new",
			"description": "The replace statement maintains referential integrity between items that contain bidirectional bridges used by the Update processor by eliminating duplicate item-IDs."
		},
		"STATUS Function": {
			"prefix": "STATUS",
			"body": "STATUS()",
			"description": "The status() function returns the value of system(0)."
		},
		"SUBROUTINE Skeleton": {
			"prefix": "SUB",
			"body": [
				"SUBROUTINE $1($2)",
				"*-----",
				"* Description: $3",
				"* Author  : $4",
				"* Date: $5",
				"*-----",
				" \\$INCLUDE Common",
				"*-----",
				" Gosub Initialise",
				"*-----",
				"  $6",
				"*-----",
				"ExitProgram:",
				"*-----",
				" Return",
				" End",
				"*-----",
				"Initialise:",
				"*-----",
				"",
				" Return"
			],
			"description": ""
		},
		"UNTIL LOOP (Modern)": {
			"prefix": "LOOP",
			"body": [
				"LOOP UNTIL $expr DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The loop statement repetitively executes (loops) until an ending condition is met. The first set of statements, if present, is executed at least once."
		},
		"WHILE LOOP (Modern)": {
			"prefix": "LOOP",
			"body": [
				"LOOP WHILE $expr DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The loop statement repetitively executes (loops) until an ending condition is met. The first set of statements, if present, is executed at least once."
		},
		"WRITE On Error": {
			"prefix": "WRITE",
			"body": "WRITE $var TO $filevar,$recordkey ON ERROR $error_statements",
			"description": "The write statement writes the item specified in dyn.array.var into the specified file, using the item-ID specified in the ID.exp."
		},
		"WRITEU Onerr": {
			"prefix": "WRITEU",
			"body": "WRITEU $var TO $filevar,$recordkey onerr $error_statements",
			"description": "The writeu form of the write statement writes a dynamic array into the specified file variable and keeps items locked that were locked by a previous readu or readvu statement."
		}
	},
	"jBase": {
		"CALLdotNET": {
			"prefix": "CALLdotNET",
			"body": "CALLdotNET $NameSpaceAndClassName, $methodName, $param SETTING $ret",
			"description": "This command allows BASIC to call any .NET assembly and is useful when using third party applications."
		},
		"CALLdotNET On Error": {
			"prefix": "CALLdotNET",
			"body": "CALLdotNET $NameSpaceAndClassName, $methodName, $param SETTING $ret ON ERROR $errStatment",
			"description": "This command allows BASIC to call any .NET assembly and is useful when using third party applications."
		},
		"CALLJ On Error": {
			"prefix": "CALLJ",
			"body": "CALLJ $packageAndClassName, $methodName, $param SETTING $ret ON ERROR $errStatement",
			"description": "The CALLJ command allows BASIC to call a Java method. CALLJ is useful when using third party applications offering a Java API (for example, publish and subscribe, messaging, etc.). "
		},
		"CASE Statement": {
			"prefix": "BEGIN",
			"body": [
				"BEGIN CASE",
				"\tCASE $1",
				"\t\t$2",
				"END CASE"
			],
			"description": "The CASE statement allows the programmer to execute a particular sequence of instructions based upon the results of a series of test expressions."
		},
		"COMPARE Left Justify": {
			"prefix": "COMPARE",
			"body": "COMPARE ($string1, $string2)",
			"description": "The COMPARE function compares two strings and returns a value indicating whether or not they are equal. "
		},
		"COMPARE Right Justify": {
			"prefix": "COMPARE",
			"body": "COMPARE ($string1, $string2, \"R\" )",
			"description": "The COMPARE function compares two strings and returns a value indicating whether or not they are equal. "
		},
		"CLEARFILE All": {
			"prefix": "CLEARFILE",
			"body": "CLEARFILE $variable SETTING $setvar ON ERROR $statements",
			"description": "The CLEARFILE statement is used to clear all the data from a file previously opened with the OPEN statement."
		},
		"CONVERT Function": {
			"prefix": "CONVERT",
			"body": "CONVERT($expression, $search, $replace)",
			"description": "The CONVERT function is the function form of the CONVERT statement. It performs exactly the same function but may also operate on an expression rather than being restricted to variables."
		},
		"CRT @": {
			"prefix": "CRT",
			"body": "CRT @($col, $row):$expression",
			"description": "This statement sends data directly to the terminal, even if a PRINTER ON statement is currently active. "
		},
		"BREAK ON": {
			"prefix": "BREAK",
			"body": "BREAK ON",
			"description": "This is used to turn the break key on in an application."
		},
		"BREAK OFF": {
			"prefix": "BREAK",
			"body": "BREAK OFF",
			"description": "This is used to turn the break key off in an application."
		},
		"CREATE Then": {
			"prefix": "CREATE",
			"body": [
				"CREATE $file_variable THEN",
				"\t$statements",
				"END"
			],
			"description": "This statement is intended to create files. It can be useful after an OPENSEQ statement to create a record in a directory file. CREATE creates the record or file if the OPENSEQ statement fails."
		},
		"CREATE Else": {
			"prefix": "CREATE",
			"body": [
				"CREATE $file_variable ELSE",
				"\t$statements",
				"END"
			],
			"description": "This statement is intended to create files. It can be useful after an OPENSEQ statement to create a record in a directory file. CREATE creates the record or file if the OPENSEQ statement fails."
		},
		"CREATE Then\/Else": {
			"prefix": "CREATE",
			"body": [
				"CREATE $file_variable THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "This statement is intended to create files. It can be useful after an OPENSEQ statement to create a record in a directory file. CREATE creates the record or file if the OPENSEQ statement fails."
		},
		"DEL Attribute": {
			"prefix": "DEL",
			"body": "DEL $variable<$attr>",
			"description": "The DEL statement is used to remove a specified element of a dynamic array."
		},
		"DEL Value": {
			"prefix": "DEL",
			"body": "DEL $variable<$attr, $value>",
			"description": "The DEL statement is used to remove a specified element of a dynamic array."
		},
		"DEL SubValue": {
			"prefix": "DEL",
			"body": "DEL $variable<$attr, $value, $subValue>",
			"description": "The DEL statement is used to remove a specified element of a dynamic array."
		},
		"DELETESEQ Then": {
			"prefix": "DELETESEQ",
			"body": [
				"DELETESEQ $expression THEN",
				"\t$statements",
				"END"
			],
			"description": "The DELETESEQ statement deletes a sequential file."
		},
		"DELETESEQ Else": {
			"prefix": "DELETESEQ",
			"body": [
				"DELETESEQ $expression ELSE",
				"\t$statements",
				"END"
			],
			"description": "The DELETESEQ statement deletes a sequential file."
		},
		"DELETESEQ Then\/Else": {
			"prefix": "DELETESEQ",
			"body": [
				"DELETESEQ $expression THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The DELETESEQ statement deletes a sequential file."
		},
		"DELETESEQ All": {
			"prefix": "DELETESEQ",
			"body": [
				"DELETESEQ Expression SETTING $setvar ON ERROR $error_statements LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The DELETESEQ statement deletes a sequential file."
		},
		"DROUND Precision": {
			"prefix": "DROUND",
			"body": "DROUND($value, $precision)",
			"description": "The DROUND function performs double-precision rounding on a value. Double-precision rounding uses two words to store a number, accommodating a larger number than in single-precision rounding, which stores each number in a single word."
		},
		"EXECUTE All": {
			"prefix": "EXECUTE",
			"body": "EXECUTE $expression CAPTURING $output RETURNING $errors PASSLIST $listname RTNLIST $variable PASSDATA $variable RTNDATA $variable",
			"description": "The EXECUTE or PERFORM statement allows the currently executing program to pause and execute another program. This may be any program, including another jBASE BASIC program or a jBASE command."
		},
		"PERFORM All": {
			"prefix": "PERFORM",
			"body": "PERFORM $expression CAPTURING $output RETURNING $errors PASSLIST $listname RTNLIST $variable PASSDATA $variable RTNDATA $variable",
			"description": "The EXECUTE or PERFORM statement allows the currently executing program to pause and execute another program. This may be any program, including another jBASE BASIC program or a jBASE command."
		},
		"EXTRACT Value": {
			"prefix": "EXTRACT",
			"body": "EXTRACT($DynArr, $attr, $value)",
			"description": "The EXTRACT function is an alternative method of accessing values in a dynamic array other than using the  syntax. "
		},
		"EXTRACT SubValue": {
			"prefix": "EXTRACT",
			"body": "EXTRACT($DynArr, $attr, $value, $subvalue)",
			"description": "The EXTRACT function is an alternative method of accessing values in a dynamic array other than using the  syntax. "
		},
		"FIELD Extract Count": {
			"prefix": "FIELD",
			"body": "FIELD($string, $delimiter, $occurrence, $extractCount)",
			"description": "This function returns a multi-character delimited field from within a string."
		},
		"FLUSH": {
			"prefix": "FLUSH",
			"body": [
				"FLUSH $file_variable THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Writes all the buffers for a sequential I\/O file immediately. Normally, sequential I\/O uses buffering for input\/output operations, and writes are not immediately flushed."
		},
		"DELETE All": {
			"prefix": "DELETE",
			"body": "DELETE $variable,$expression SETTING $setvar ON ERROR $statements",
			"description": "This statement is used to delete a record from a jBASE file."
		},
		"DELETEU All": {
			"prefix": "DELETEU",
			"body": "DELETEU $variable,$expression SETTING $setvar ON ERROR $statements",
			"description": "The DELETEU statement is used to delete a record without releasing the update record lock set by a previous READU statement."
		},
		"GETUSERGROUP": {
			"prefix": "GETUSERGROUP",
			"body": "GETUSERGROUP($uid)",
			"description": "For UNIX, the jBC function GETUSERGROUP returns the group number for the user ID specified by @uid."
		},
		"IF Then": {
			"prefix": "IF",
			"body": [
				"IF $1 THEN",
				"\t$2",
				"END"
			],
			"description": "IF \/ THEN"
		},
		"IF Then\/Else": {
			"prefix": "IF",
			"body": [
				"IF $1 THEN",
				"\t$2",
				"END ELSE",
				"\t$3",
				"END"
			],
			"description": "IF \/ ELSE"
		},
		"INPUT @": {
			"prefix": "INPUT",
			"body": "INPUT @($col, $row): $var",
			"description": "The INPUT statement allows the program to collect data from the current input device, which will normally be the terminal keyboard but may be stacked input from the same or separate program. The function takes the general form: "
		},
		"INPUT FOR": {
			"prefix": "INPUT",
			"body": [
				"INPUT $var FOR $deciseconds THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The INPUT statement allows the program to collect data from the current input device, which will normally be the terminal keyboard but may be stacked input from the same or separate program. The function takes the general form: "
		},
		"INPUT With": {
			"prefix": "INPUT",
			"body": "INPUT $var WITH $delim",
			"description": "The INPUT statement allows the program to collect data from the current input device, which will normally be the terminal keyboard but may be stacked input from the same or separate program. The function takes the general form: "
		},
		"IN For": {
			"prefix": "IN",
			"body": [
				"IN $var FOR $deciseconds THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The IN statement allows the program to receive raw data from the input device, which is normally the terminal keyboard, one character at a time."
		},
		"JBASETHREADCreate": {
			"prefix": "JBASETHREADCreate",
			"body": "JBASETHREADCreate($ProgramName, $Arguments, $User, $Handle)",
			"description": "Use the JBASETHREADCreate command to start a new thread."
		},
		"JBASETHREADStatus": {
			"prefix": "JBASETHREADStatus",
			"body": "JBASETHREADStatus($ThreadList)",
			"description": "The JBASETHREADStatus command shows the status of all running threads. "
		},
		"LOCATE Order By": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE $search IN $subject BY $orderBy SETTING $returnVar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The LOCATE statement finds the position of an element within a specified dimension of a dynamic array."
		},
		"LOCATE Function": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE($search, subject, $attr, $value; $returnVar) THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The LOCATE statement finds the position of an element within a specified dimension of a dynamic array."
		},
		"LOCATE Function Order By": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE($search, subject, $attr, $value; $returnVar; $orderBy) THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The LOCATE statement finds the position of an element within a specified dimension of a dynamic array."
		},
		"LOOP While": {
			"prefix": "LOOP",
			"body": [
				"LOOP",
				"\t$statement1",
				"WHILE $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The LOOP construct allows the programmer to specify loops with multiple exit conditions. The construct takes the general form: "
		},
		"LOOP Until": {
			"prefix": "LOOP",
			"body": [
				"LOOP",
				"\t$statement1",
				"UNTIL $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The LOOP construct allows the programmer to specify loops with multiple exit conditions. The construct takes the general form: "
		},
		"WHILE LOOP (Modern)": {
			"prefix": "LOOP",
			"body": [
				"LOOP WHILE $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The LOOP construct allows the programmer to specify loops with multiple exit conditions. The construct takes the general form: "
		},
		"UNTIL LOOP (Modern)": {
			"prefix": "LOOP",
			"body": [
				"LOOP UNTIL $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The LOOP construct allows the programmer to specify loops with multiple exit conditions. The construct takes the general form: "
		},
		"MATBUILD Using": {
			"prefix": "MATBUILD",
			"body": "MATBUILD $variable FROM $array, $expression1, $expression2 USING $delimiter",
			"description": "The MATBUILD statement creates a dynamic array out of a dimensioned array."
		},
		"MATPARSE Using": {
			"prefix": "MATPARSE",
			"body": "MATPARSE $array, $expression1, $expression2 FROM $variable1 USING $expression3 SETTING $variable2",
			"description": "The MATPARSE statement is used to assign the elements of a matrix from the elements of a dynamic array."
		},
		"MATREAD Setting": {
			"prefix": "MATREAD",
			"body": [
				"MATREAD $array FROM $expression SETTING $setvar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The MATREAD statement allows a record stored in a jBASE file to be read and mapped directly into a dimensioned array."
		},
		"MATREAD On Error": {
			"prefix": "MATREAD",
			"body": [
				"MATREAD $array FROM $expression ON ERROR $statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The MATREAD statement allows a record stored in a jBASE file to be read and mapped directly into a dimensioned array."
		},
		"MATREAD Locked": {
			"prefix": "MATREAD",
			"body": [
				"MATREAD $array FROM $expression LOCKED $statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The MATREAD statement allows a record stored in a jBASE file to be read and mapped directly into a dimensioned array."
		},
		"MATREAD All": {
			"prefix": "MATREAD",
			"body": [
				"MATREAD $array FROM $expression SETTING $setvar  ON ERROR $statements LOCKED $statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The MATREAD statement allows a record stored in a jBASE file to be read and mapped directly into a dimensioned array."
		},
		"MATREADU All": {
			"prefix": "MATREADU",
			"body": [
				"MATREADU $array FROM $expression SETTING $setvar  ON ERROR $statements LOCKED $statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "This statement allows a record stored in a jBASE file to be read and mapped directly into a dimensioned array. The record will also be locked for update by the program."
		},
		"MATWRITE All": {
			"prefix": "MATWRITE",
			"body": "MATWRITE $array ON $expression SETTING $setvar ON ERROR $statements",
			"description": "The MATWRITE statement transfers the entire contents of a dimensioned array to a specified record on disc."
		},
		"MATWRITEU All": {
			"prefix": "MATWRITEU",
			"body": "MATWRITEU $array ON $expression SETTING $setvar ON ERROR $statements",
			"description": "The MATWRITEU statement transfers the entire contents of a dimensioned array to a specified record on file, in the same manner as the MATWRITE statement. An existing record lock will be preserved."
		},
		"OPEN Setting": {
			"prefix": "OPEN",
			"body": [
				"OPEN $filename TO $variable SETTING $setvar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The OPEN statement opens a file or device to a descriptor variable."
		},
		"OPEN Then\/Else": {
			"prefix": "OPEN",
			"body": [
				"OPEN $filename TO $variable THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The OPEN statement opens a file or device to a descriptor variable."
		},
		"OSBWRITE At": {
			"prefix": "OSBWRITE",
			"body": "OSBWRITE $expression TO $filevar AT $byte_expr",
			"description": "The OSBWRITE command writes an expression to a sequential file starting at a specified byte location. The command takes the general form:"
		},
		"OSBWRITE Nodelay": {
			"prefix": "OSBWRITE",
			"body": "OSBWRITE $expression TO $filevar NODELAY",
			"description": "The OSBWRITE command writes an expression to a sequential file starting at a specified byte location. The command takes the general form:"
		},
		"OSBWRITE ON ERROR": {
			"prefix": "OSBWRITE",
			"body": "OSBWRITE $expression TO $filevar ON ERROR $statements",
			"description": "The OSBWRITE command writes an expression to a sequential file starting at a specified byte location. The command takes the general form:"
		},
		"OSBWRITE All": {
			"prefix": "OSBWRITE",
			"body": "OSBWRITE $expression TO $filevar AT byte_expr NODELAY ON ERROR $statements",
			"description": "The OSBWRITE command writes an expression to a sequential file starting at a specified byte location. The command takes the general form:"
		},
		"OPENDEV Locked": {
			"prefix": "OPENDEV",
			"body": [
				"OPENDEV $Device TO $filevar LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Opens a device (or file) for sequential writing and\/or reading."
		},
		"OPENINDEX Setting": {
			"prefix": "OPENINDEX",
			"body": [
				"OPENINDEX $filename,$indexname TO $indexvar SETTING $setvar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The OPENINDEX statement is used to open a particular index definition for a particular file. This index file variable can later be used with the SELECT statement."
		},
		"OPENPATH Setting": {
			"prefix": "OPENPATH",
			"body": [
				"OPENPATH $expression1 TO $variable SETTING $setvar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The OPENPATH statement opens a file (given an absolute or relative path) to a descriptor variable within jBASE BASIC. "
		},
		"OPENSEQ Path": {
			"prefix": "OPENSEQ",
			"body": [
				"OPENSEQ $Path $READONLY TO $FileVar LOCKED $statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Opens a file for sequential writing and\/or reading."
		},
		"OPENSEQ File": {
			"prefix": "OPENSEQ",
			"body": [
				"OPENSEQ $Path,$File $READONLY TO $FileVar LOCKED $statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Opens a file for sequential writing and\/or reading."
		},
		"OSBREAD At": {
			"prefix": "OSBREAD",
			"body": "OSBREAD $var FROM $filevar AT $byte_expr LENGTH $length_expr",
			"description": "The OSBREAD command reads data from a file starting at a specified byte location for a certain length of bytes, and assigns the data to a variable."
		},
		"OSBREAD ON ERROR": {
			"prefix": "OSBREAD",
			"body": "OSBREAD $var FROM $filevar LENGTH $length_expr ON ERROR $statements",
			"description": "The OSBREAD command reads data from a file starting at a specified byte location for a certain length of bytes, and assigns the data to a variable."
		},
		"OSBREAD All": {
			"prefix": "OSBREAD",
			"body": "OSBREAD $var FROM $filevar AT $byte_expr LENGTH $length_expr ON ERROR $statements",
			"description": "The OSBREAD command reads data from a file starting at a specified byte location for a certain length of bytes, and assigns the data to a variable."
		},
		"OSCLOSE ON ERROR": {
			"prefix": "OSCLOSE",
			"body": "OSCLOSE $filevar ON ERROR $statements",
			"description": "The OSCLOSE command closes a sequential file that was previously opened with the OSOPEN or OPENSEQ command. the command takes the general form:"
		},
		"OSDELETE ON ERROR": {
			"prefix": "OSDELETE",
			"body": "OSDELETE $filename ON ERROR $statements",
			"description": "The OSDELETE command deletes a NT or UNIX file."
		},
		"OSOPEN ON ERROR": {
			"prefix": "OSOPEN",
			"body": [
				"OSOPEN $filename TO $filevar ON ERROR $statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The OSOPEN command opens a sequential file that does not use CHAR(10) as the line delimiter. The command takes the general form: "
		},
		"OSREAD ON ERROR": {
			"prefix": "OSREAD",
			"body": [
				"OSREAD $Variable FROM $expression ON ERROR $Statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Reads an OS file."
		},
		"PRINTER": {
			"prefix": "PRINTER",
			"body": "PRINTER $ON_OFF_CLOSE",
			"description": "Use the PRINTER statement to control the destination of output from the PRINT statement."
		},
		"READ All": {
			"prefix": "READ",
			"body": [
				"READ $var FROM $filevar,$recordkey SETTING $setvar ON ERROR $statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READ statement allows a program to read a record from a previously opened file into a variable."
		},
		"READL All": {
			"prefix": "READL",
			"body": [
				"READL $var FROM $filevar,$recordkey SETTING $setvar ON ERROR $statement LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READL statement allows a process to read a record from a previously opened file into a variable and takes a read-only shared lock on the record. It respects all records locked with theREADU statement but allows other processes using READL to share the same lock."
		},
		"READLIST Setting": {
			"prefix": "READLIST",
			"body": [
				"READLIST $variable1 FROM $expression SETTING $variable2 THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "READLIST allows the program to retrieve a previously stored list, into a variable."
		},
		"READNEXT All": {
			"prefix": "READNEXT",
			"body": [
				"READNEXT $variable1, $variable2 FROM $list SETTING $setvar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "READNEXT retrieves the next element in a list variable."
		},
		"READPREV": {
			"prefix": "READPREV",
			"body": "READPREV $variable FROM $list",
			"description": "This statement is syntactically similar to the READNEXT but it works in reverse order."
		},
		"READPREV All": {
			"prefix": "READPREV",
			"body": [
				"READPREV $variable1, $variable2 FROM $list SETTING $setvar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "This statement is syntactically similar to the READNEXT but it works in reverse order."
		},
		"READV All": {
			"prefix": "READV",
			"body": [
				"READV $var FROM $filevar,$recordkey,$attr SETTING $setvar ON ERROR $error_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READV statement allows a program to read a specific field from a record in a previously opened file into a variable."
		},
		"READU All": {
			"prefix": "READU",
			"body": [
				"READU $var FROM $filevar,$recordkey SETTING $setvar ON ERROR $error_statements LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READU statement allows a program to read a record from a previously opened file into a variable. It respects record locking and locks the specified record for update."
		},
		"READVL": {
			"prefix": "READVL",
			"body": [
				"READVL $var FROM $filevar,$recordkey,$attr THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READVL statement acquires a shared record lock and then reads a field from the record. "
		},
		"READVL All": {
			"prefix": "READVL",
			"body": [
				"READVL $var FROM $filevar,$recordkey,$attr SETTING $setvar ON ERROR $error_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READVL statement acquires a shared record lock and then reads a field from the record. "
		},
		"READVU All": {
			"prefix": "READVU",
			"body": [
				"READVU $var FROM $filevar,$recordkey,$attr SETTING $setvar ON ERROR $error_statements LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READVU statement allows a program to read a specific field in a record in a previously opened file into a variable. It also respects record locking and locks the specified record for update. "
		},
		"WRITE All": {
			"prefix": "WRITE",
			"body": "WRITE $var TO $filevar,$recordkey SETTING $setvar ON ERROR $error_statements",
			"description": "The WRITE statement allows a program to write a record into a previously opened file."
		},
		"WRITELIST All": {
			"prefix": "WRITELIST",
			"body": "WRITELIST $var TO $expression SETTING $setvar ON ERROR $error_statements",
			"description": "WRITELIST allows the program to store a list held in a jBASE BASIC variable to the global list file."
		},
		"WRITEU All": {
			"prefix": "WRITEU",
			"body": "WRITEU $var TO $filevar,$recordkey SETTING $setvar ON ERROR $error_statements",
			"description": "The WRITEU statement allows a program to write a record into a previously opened file. An existing record lock will be preserved."
		},
		"WRITEV All": {
			"prefix": "WRITEV",
			"body": "WRITEV $var TO $filevar,$recordkey,$attr SETTING $setvar ON ERROR $error_statements",
			"description": "The WRITEV statement allows a program to write a specific field of a record in a previously opened file."
		},
		"WRITEVU All": {
			"prefix": "WRITEVU",
			"body": "WRITEVU $var TO $filevar,$recordkey,$attr SETTING $setvar ON ERROR $error_statements",
			"description": "The WRITEVU statement allows a program to write a specific field on a record in a previously opened file. An existing record lock will be preserved. The statement takes the general form: "
		},
		"RANDOMIZE": {
			"prefix": "RANDOMIZE",
			"body": "RANDOMIZE $expression",
			"description": "Use the RANDOMIZE statement with an expression to make the RND function generate the same sequence of random numbers each time the program is run."
		},
		"FOR Loop": {
			"prefix": "FOR",
			"body": [
				"FOR $1 = $2 To $3",
				"$4",
				"NEXT $1"
			],
			"description": "Standard FOR Loop"
		},
		"FOR Step": {
			"prefix": "FOR",
			"body": [
				"FOR $1 = $2 To $3 STEP $4",
				"$5",
				"NEXT $1"
			],
			"description": "Standard FOR Loop"
		},
		"SUBROUTINE Skeleton": {
			"prefix": "SUB",
			"body": [
				"SUBROUTINE $1($2)",
				"*-----",
				"* Description : $3",
				"* Author  : $4",
				"* Date: $5",
				"*-----",
				" \\$INCLUDE Common",
				"*-----",
				" Gosub Initialise",
				"*-----",
				"  $6",
				"*-----",
				"ExitProgram:",
				"*-----",
				" Return",
				" End",
				"*-----",
				"Initialise:",
				"*-----",
				"",
				" Return"
			],
			"description": "Standard Subroutine Skeleton"
		},
		"$append": {
			"prefix": "$append",
			"body": "\\$append($value)",
			"description": "The $append() method allows you to add (append) a value to the end of an array."
		},
		"$append reject dupes": {
			"prefix": "$append",
			"body": "\\$append($value, 1)",
			"description": "The $append() method allows you to add (append) a value to the end of an array."
		},
		"$append case sensitive": {
			"prefix": "$append",
			"body": "\\$append($value, $reject_duplicates, 1)",
			"description": "The $append() method allows you to add (append) a value to the end of an array."
		},
		"$classname": {
			"prefix": "$classname",
			"body": "\\$classname()",
			"description": "The $classname() method returns the name of the class as a text string."
		},
		"$clear": {
			"prefix": "$clear",
			"body": "\\$clear()",
			"description": "The $clear() method clears (deletes) all the members (properties) from an object leaving the object void."
		},
		"$clone": {
			"prefix": "$clone",
			"body": "\\$clone()",
			"description": "The $clone() method creates an exact copy of an existing object.\nMaking any changes to the original object does not affect the cloned object, and vice versa.\nThe cloned object contains all nested objects and arrays."
		},
		"$delete": {
			"prefix": "$delete",
			"body": "\\$delete($property_name)",
			"description": "The $delete() method deletes a property from an object or array."
		},
		"$dump": {
			"prefix": "$dump",
			"body": "\\$dump($mode)",
			"description": "The $dump() method displays the internal contents of an object."
		},
		"$equals": {
			"prefix": "$equals",
			"body": "\\$equals($var)",
			"description": "The $equals(), or $equal(), method tests if two objects or arrays are equal. \nFor objects, the properties can be in any order but the properties and their values must be the same in both objects. \nFor arrays, they must be absolutely equal. If you have the same values in both arrays, but in different positions, they will not be considered equal.\nAll nested objects and arrays are compared."
		},
		"$fromfile": {
			"prefix": "$fromfile",
			"body": "\\$fromfile($path)",
			"description": "The $fromfile() static method creates an object from an operating system file. The file must be in a valid JSON format."
		},
		"$fromjson": {
			"prefix": "$fromjson",
			"body": "\\$fromjson()",
			"description": "The $fromjson() method converts a valid JSON string to an object. This is the complement of the $tojson() method."
		},
		"$insert": {
			"prefix": "$insert",
			"body": "\\$insert($value, $position)",
			"description": "The $insert() method inserts a value before a specified position in an array."
		},
		"$isfile": {
			"prefix": "$isfile",
			"body": "\\$isfile()",
			"description": "The $isfile() method is used to determine if a variable is a file variable."
		},
		"$ismethod": {
			"prefix": "$ismethod",
			"body": "\\$ismethod($method_name)",
			"description": "The $ismethod() method is used to determine if a method exists for a specific class."
		},
		"$isobject": {
			"prefix": "$isobject",
			"body": "\\$isobject()",
			"description": "The $isobject() method is used to determine if a variable is an object or array."
		},
		"$isproperty": {
			"prefix": "$isproperty",
			"body": "\\$isproperty($property_name)",
			"description": "The $isproperty() method is used to determine if a variable is a property of an object or array."
		},
		"$keys": {
			"prefix": "$keys",
			"body": "\\$keys($1)",
			"description": "The $keys() method will return an array of all the key values from an object. \nThis method is intended to be compatible with the JavaScript keys() method, but with a small syntax enhancement. The functionality created with $keys() can easily be replicated using iterators and the $iterate() class, but this provides some compatibility for those more familiar with JavaScript."
		},
		"$lasterror": {
			"prefix": "$lasterror",
			"body": "\\$lasterror()",
			"description": "The $lasterror method returns an object with the results of a $fromjson() method call, and since it is an object its properties can be accessed."
		},
		"$locate": {
			"prefix": "$locate",
			"body": "\\$locate($value)",
			"description": "The $locate() method is used to find an value in a Dynamic Objects array, optionally specifying a case insensitive search."
		},
		"$locate case insensitive": {
			"prefix": "$locate",
			"body": "\\$locate($value, 1)",
			"description": "The $locate() method is used to find an value in a Dynamic Objects array, optionally specifying a case insensitive search."
		},
		"$merge arrays": {
			"prefix": "$merge",
			"body": "\\$merge($array)",
			"description": "The $merge() method combines (concatenates) one array with another array."
		},
		"$merge objects": {
			"prefix": "$merge",
			"body": "\\$merge($obj, $precedence)",
			"description": "The $merge() method combines (merges) one object into another object, optionally specifying which object takes precedence if both objects contain  the same properties."
		},
		"$objecttype": {
			"prefix": "$objecttype",
			"body": "\\$objecttype()",
			"description": "The $objecttype() method returns the type of the object."
		},
		"$prepend": {
			"prefix": "$prepend",
			"body": "\\$prepend($value)",
			"description": "The $prepend() method allows you to insert a new value at the beginning of the array."
		},
		"$prepend reject dupes": {
			"prefix": "$prepend",
			"body": "\\$prepend($value, 1)",
			"description": "The $prepend() method allows you to insert a new value at the beginning of the array."
		},
		"$prepend case sensitive": {
			"prefix": "$prepend",
			"body": "\\$prepend($value, $reject_duplicates, 1)",
			"description": "The $prepend() method allows you to insert a new value at the beginning of the array."
		},
		"$refcount": {
			"prefix": "$refcount",
			"body": "\\$refcount()",
			"description": "The $refcount() method returns the number of variables that reference the same object."
		},
		"$setboolean": {
			"prefix": "$setboolean",
			"body": "\\$setboolean($property_name_or_index, $boolean)",
			"description": "The $setboolean() method allows you to create boolean values in JSON output that wouldn't normally be supported by native jBASE data types."
		},
		"$setnull": {
			"prefix": "$setnull",
			"body": "\\$setnull($property_name_or_index)",
			"description": "The $setnull() method sets a value to null in an object or an array. These null values can only be used in JSON output that wouldn't normally be supported by native jBASE data types."
		},
		"$setserialize": {
			"prefix": "$setserialize",
			"body": "\\$setserialize($1)",
			"description": "The $setserialize() method provides a limited amount of control over a serialized object when a character string is required and a dynamic object is the source. The object is serialized to a JSON string."
		},
		"$size": {
			"prefix": "$size",
			"body": "\\$size()",
			"description": "The $size() method returns the number of properties in an object or the number of values in an array."
		},
		"$sort": {
			"prefix": "$sort",
			"body": "\\$sort($sequence)",
			"description": "The $sort() method sorts the properties in an object, optionally specifying sort sequence."
		},
		"$tojson": {
			"prefix": "$tojson",
			"body": "\\$tojson($format)",
			"description": "The $tojson() method converts an object to a JSON string and optionally formats the string in a number of ways. This is the complement of the $fromjson() method."
		},
		"$valuetype": {
			"prefix": "$valuetype",
			"body": "\\$valuetype($property_name)",
			"description": "The $valuetype() method returns type of an object's property."
		}
	},
	"OpenQM": {
		"ABORTE": {
			"prefix": "ABORTE",
			"body": "ABORTE $messagenum, $expression",
			"description": "The ABORT statement terminates the current program, returning to the command prompt. ABORTE and ABORTM provide compatibility with other multivalue database products."
		},
		"ABORTM": {
			"prefix": "ABORTM",
			"body": "ABORTM $messagenum, $expression",
			"description": "The ABORT statement terminates the current program, returning to the command prompt. ABORTE and ABORTM provide compatibility with other multivalue database products."
		},
		"BREAK OFF": {
			"prefix": "BREAK",
			"body": "BREAK OFF",
			"description": "The BREAK statement allows the action of the break key to be disabled during program execution."
		},
		"BREAK ON": {
			"prefix": "BREAK",
			"body": "BREAK ON",
			"description": "The BREAK statement allows the action of the break key to be disabled during program execution."
		},
		"CHARS": {
			"prefix": "CHARS",
			"body": "CHARS($DynArr)",
			"description": "The CHARS() function takes a dynamic array seq and returns a similarly structured dynamic array in which each element contains the character with the ASCII value from the corresponding element of seq."
		},
		"CLASS All": {
			"prefix": "CLASS",
			"body": [
				"CLASS $name MAX.ARGS $limit INHERITS $classlist",
				"\t$statements",
				"END"
			],
			"description": "The CLASS statement declares a class module."
		},
		"CLEARFILE All": {
			"prefix": "CLEARFILE",
			"body": "CLEARFILE $variable ON ERROR $statements",
			"description": "The CLEARFILE statement clears a file previously opened using the OPEN statement, deleting all records."
		},
		"CLOSE All": {
			"prefix": "CLOSE",
			"body": "CLOSE $variable ON ERROR $error_statements",
			"description": "The CLOSE statement closes a file previously opened using the OPEN or OPENPATH statement."
		},
		"CLOSE.SOCKET ": {
			"prefix": "CLOSE.SOCKET ",
			"body": "CLOSE.SOCKET $skt",
			"description": "The CLOSE.SOCKET statement closes a socket."
		},
		"COMPARE Left Justify": {
			"prefix": "COMPARE",
			"body": "COMPARE ($string1, $string2)",
			"description": "The COMPARE() function compares two strings using the same rules as the LOCATE statement. The COMPARES() function is similar but operates on a multivalued list of strings."
		},
		"COMPARE Right Justify": {
			"prefix": "COMPARE",
			"body": "COMPARE ($string1, $string2, \"R\" )",
			"description": "The COMPARE() function compares two strings using the same rules as the LOCATE statement. The COMPARES() function is similar but operates on a multivalued list of strings."
		},
		"COMPARES Left Justify": {
			"prefix": "COMPARE",
			"body": "COMPARE ($array, $string2)",
			"description": "The COMPARES() function treats string1 as a dynamic array, comparing each element in turn with string2 and returning a similarly structured dynamic array of results."
		},
		"COMPARES Right Justify": {
			"prefix": "COMPARE",
			"body": "COMPARE ($array, $string2, \"R\" )",
			"description": "The COMPARES() function treats string1 as a dynamic array, comparing each element in turn with string2 and returning a similarly structured dynamic array of results."
		},
		"CONVERT Function": {
			"prefix": "CONVERT",
			"body": "CONVERT($fromchars, $tostring, $var)",
			"description": "The CONVERT statement and CONVERT() function replace selected characters by others in a string. The CONVERT statement performs this conversion in-situ; the CONVERT() function leaves the source string unchanged and returns the modified value."
		},
		"CREATE Else": {
			"prefix": "CREATE",
			"body": [
				"CREATE $file_variable ELSE",
				"\t$statements",
				"END"
			],
			"description": "The CREATE statement creates an empty directory file record after a previous OPENSEQ has reported that the record did not exist."
		},
		"CREATE Then": {
			"prefix": "CREATE",
			"body": [
				"CREATE $file_variable THEN",
				"\t$statements",
				"END"
			],
			"description": "The CREATE statement creates an empty directory file record after a previous OPENSEQ has reported that the record did not exist."
		},
		"CREATE Then\/Else": {
			"prefix": "CREATE",
			"body": [
				"CREATE $file_variable THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The CREATE statement creates an empty directory file record after a previous OPENSEQ has reported that the record did not exist."
		},
		"CREATE.FILE Directory": {
			"prefix": "CREATE.FILE",
			"body": "CREATE.FILE $path DIRECTORY",
			"description": "The CREATE.FILE statement creates the operating system representation of a directory or dynamic hash file."
		},
		"CREATE.FILE Dynamic.File": {
			"prefix": "CREATE.FILE",
			"body": "CREATE.FILE $path DYNAMIC GROUP.SIZE $groupsz BIG.REC.SIZE $bigrec MIN.MODULUS $minmod SPLIT.LOAD $split MERGE.LOAD $merge VERSION $ver ON ERROR $err_statements",
			"description": "The CREATE.FILE statement creates the operating system representation of a directory or dynamic hash file."
		},
		"CRT @": {
			"prefix": "CRT",
			"body": "CRT @($col, $row):$expression",
			"description": "The DISPLAY statement sends data to the display. The synonym CRT can be used in place of DISPLAY."
		},
		"DATE": {
			"prefix": "DATE",
			"body": "DATE()",
			"description": "The DATE() function returns the internal value of the current date."
		},
		"DEL Attribute": {
			"prefix": "DEL",
			"body": "DEL $variable<$attr>",
			"description": "The DEL statement and DELETE() function delete a field, value or subvalue from a dynamic array. Used with a data collection, the DEL statement deletes an element."
		},
		"DEL SubValue": {
			"prefix": "DEL",
			"body": "DEL $variable<$attr, $value, $subValue>",
			"description": "The DEL statement and DELETE() function delete a field, value or subvalue from a dynamic array. Used with a data collection, the DEL statement deletes an element."
		},
		"DEL Value": {
			"prefix": "DEL",
			"body": "DEL $variable<$attr, $value>",
			"description": "The DEL statement and DELETE() function delete a field, value or subvalue from a dynamic array. Used with a data collection, the DEL statement deletes an element."
		},
		"DELETE All": {
			"prefix": "DELETE",
			"body": "DELETE $filevar,$recordkey ON ERROR $statements",
			"description": "The DELETE statement deletes a record from an open file. The DELETEU statement is similar but it preserves locks."
		},
		"DELETESEQ All": {
			"prefix": "DELETESEQ",
			"body": [
				"DELETESEQ $filename, $id ON ERROR $error_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The DELETESEQ statement deletes an operating system file."
		},
		"DELETESEQ Else": {
			"prefix": "DELETESEQ",
			"body": [
				"DELETESEQ $filename, $id ELSE",
				"\t$statements",
				"END"
			],
			"description": "The DELETESEQ statement deletes an operating system file."
		},
		"DELETESEQ Then": {
			"prefix": "DELETESEQ",
			"body": [
				"DELETESEQ $filename, $id THEN",
				"\t$statements",
				"END"
			],
			"description": "The DELETESEQ statement deletes an operating system file."
		},
		"DELETESEQ Then\/Else": {
			"prefix": "DELETESEQ",
			"body": [
				"DELETESEQ $filename, $id THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The DELETESEQ statement deletes an operating system file."
		},
		"DELETEU All": {
			"prefix": "DELETEU",
			"body": "DELETEU $filevar,$recordkey ON ERROR $statements",
			"description": "The DELETE statement deletes a record from an open file. The DELETEU statement is similar but it preserves locks."
		},
		"DIM": {
			"prefix": "DIM",
			"body": "DIM $variable($numbers)",
			"description": "The DIMENSION statement is used to set the dimensions of a matrix. The short form DIM may be used in place of DIMENSION. The REDIMENSION or REDIM statement is identical except where the matrix is a subroutine argument."
		},
		"EXECUTE All": {
			"prefix": "EXECUTE",
			"body": "EXECUTE $expression TRAPPING ABORTS CAPTURING $var NO.TTY PASSLIST $listname RTNLIST $variable SILENT STACKLIST RETURNING $statusvar",
			"description": "The EXECUTE statement enables a QMBasic program to execute any command. The synonym PERFORM can be used in place of EXECUTE."
		},
		"EXTRACT SubValue": {
			"prefix": "EXTRACT",
			"body": "EXTRACT($DynArr, $attr, $value, $subvalue)",
			"description": "The EXTRACT() function extracts a field, value or subvalue from a dynamic array."
		},
		"EXTRACT Value": {
			"prefix": "EXTRACT",
			"body": "EXTRACT($DynArr, $attr, $value)",
			"description": "The EXTRACT() function extracts a field, value or subvalue from a dynamic array."
		},
		"FIELD Extract Count": {
			"prefix": "FIELD",
			"body": "FIELD($string, $delimiter, $occurrence, $extractCount)",
			"description": "The FIELD() function returns one or more delimited substrings from a string. The FIELDS() function is similar to FIELD() but operates on a multivalued string, returning a similarly structured dynamic array of results."
		},
		"FOR Loop": {
			"prefix": "FOR",
			"body": [
				"FOR $1 = $2 TO $3",
				"$4",
				"NEXT $1"
			],
			"description": "The FOR \/ NEXT statement defines a group of statements to be executed with an iterative control variable."
		},
		"FOR Step": {
			"prefix": "FOR",
			"body": [
				"FOR $1 = $2 TO $3 STEP $4",
				"$5",
				"NEXT $1"
			],
			"description": "The FOR \/ NEXT statement defines a group of statements to be executed with an iterative control variable."
		},
		"FOR EACH": {
			"prefix": "FOR EACH",
			"body": [
				"FOR EACH $var IN $str",
				"$statements",
				"NEXT $var"
			],
			"description": "The FOR \/ NEXT statement defines a group of statements to be executed with an iterative control variable."
		},
		"IF Then": {
			"prefix": "IF",
			"body": [
				"IF $1 THEN",
				"\t$2",
				"END"
			],
			"description": "The IF statement provides conditional execution of one or more statements."
		},
		"IF Then\/Else": {
			"prefix": "IF",
			"body": [
				"IF $1 THEN",
				"\t$2",
				"END ELSE",
				"\t$3",
				"END"
			],
			"description": "The IF statement provides conditional execution of one or more statements."
		},
		"IN For": {
			"prefix": "IN",
			"body": [
				"IN $var FOR $deciseconds THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The IN statement reads a single character from the terminal with an optional timeout."
		},
		"INPUT All": {
			"prefix": "INPUT",
			"body": [
				"INPUT $var , $length, $fill $modes THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The INPUT statement enables entry of data from the keyboard or from previously stored DATA statements. The INPUTDW statement is identical except that it limits data length based on display width."
		},
		"KEYINVC": {
			"prefix": "KEYINVC",
			"body": "KEYINVC($timeout)",
			"description": "The KEYINV() and KEYINCV() functions read a single keystroke from the keyboard."
		},
		"LOCATE Function": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE($search, subject, $attr, $value; $returnVar) THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The LOCATE statement searches a dynamic array for a given field, value or subvalue. The LOCATE() function provides similar capabilities and is particularly suited to use in dictionary I-type items."
		},
		"LOCATE Function Order By": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE($search, subject, $attr, $value; $returnVar; $orderBy) THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The LOCATE statement searches a dynamic array for a given field, value or subvalue. The LOCATE() function provides similar capabilities and is particularly suited to use in dictionary I-type items."
		},
		"LOCATE Order By": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE $search IN $subject BY $orderBy SETTING $returnVar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The LOCATE statement searches a dynamic array for a given field, value or subvalue. The LOCATE() function provides similar capabilities and is particularly suited to use in dictionary I-type items."
		},
		"LOOP Until": {
			"prefix": "LOOP",
			"body": [
				"LOOP",
				"\t$statement1",
				"UNTIL $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The LOOP statement introduces a sequence of statements to be executed repeatedly."
		},
		"LOOP While": {
			"prefix": "LOOP",
			"body": [
				"LOOP",
				"\t$statement1",
				"WHILE $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The LOOP statement introduces a sequence of statements to be executed repeatedly."
		},
		"MAT Function": {
			"prefix": "MAT",
			"body": "MAT($array, $elements)",
			"description": "The MAT() function creates an array for insertion into a data collection."
		},
		"MATBUILD Using": {
			"prefix": "MATBUILD",
			"body": "MATBUILD $variable FROM $array, $startexpr, $endexpr USING $delimiter",
			"description": "The MATBUILD statement constructs a dynamic array from the elements of a matrix."
		},
		"MATPARSE Using": {
			"prefix": "MATPARSE",
			"body": "MATPARSE $mat FROM $str USING $delim SETTING $var",
			"description": "The MATPARSE statement breaks a delimited string into component substrings, assigning each to an element of a matrix. "
		},
		"MATREAD All": {
			"prefix": "MATREAD",
			"body": [
				"MATREAD $mat ENCODING $name FROM $filevar, $recordkey ON ERROR $err_statements LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The MATREAD statement reads a record from a file, assigning each field to an element of a matrix."
		},
		"MATREADL All": {
			"prefix": "MATREADL",
			"body": [
				"MATREADL $mat ENCODING $name FROM $filevar, $recordkey ON ERROR $err_statements LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The MATREADL statement is similar to MATREAD but sets a read lock on the record. The MATREADU statement sets an update lock on the record."
		},
		"MATREADU All": {
			"prefix": "MATREADU",
			"body": [
				"MATREADU $mat ENCODING $name FROM $filevar, $recordkey ON ERROR $err_statements LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The MATREADL statement is similar to MATREAD but sets a read lock on the record. The MATREADU statement sets an update lock on the record."
		},
		"MATWRITE All": {
			"prefix": "MATWRITE",
			"body": "MATWRITE $mat ENCODING $name TO $filevar, $recordkey ON ERROR $statements",
			"description": "The MATWRITE statement builds a record from successive elements of a matrix and writes this to a file."
		},
		"MATWRITEU All": {
			"prefix": "MATWRITEU",
			"body": "MATWRITEU $mat ENCODING $name TO $filevar, $recordkey ON ERROR $statements",
			"description": "The MATWRITEU statement is similar but preserves any lock on the record being written."
		},
		"NUMERIC": {
			"prefix": "NUMERIC",
			"body": "NUMERIC($expr)",
			"description": "The NUMERIC() function converts a value to Numeric form."
		},
		"OPEN All": {
			"prefix": "OPEN",
			"body": [
				"OPEN $filename TO $filevar ON ERROR $err_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The OPEN statement opens a directory file or dynamic file, associating it with a file variable."
		},
		"OPENPATH On Error": {
			"prefix": "OPENPATH",
			"body": [
				"OPENPATH $pathname TO $filevar ON ERROR $err_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The OPENPATH statement opens a directory file or dynamic file by pathname, associating it with a file variable."
		},
		"OPENSEQ File": {
			"prefix": "OPENSEQ",
			"body": [
				"OPENSEQ $filename,$id $options TO $FileVar ON ERROR $err LOCKED $lock THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The OPENSEQ statement opens a record of a directory file, a device or a pipe for sequential access."
		},
		"OPENSEQ Path": {
			"prefix": "OPENSEQ",
			"body": [
				"OPENSEQ $Path $options TO $FileVar ON ERROR $err LOCKED $lock THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The OPENSEQ statement opens a record of a directory file, a device or a pipe for sequential access."
		},
		"PERFORM All": {
			"prefix": "PERFORM",
			"body": "PERFORM $expression TRAPPING ABORTS CAPTURING $var NO.TTY PASSLIST $listname RTNLIST $variable SILENT STACKLIST RETURNING $statusvar",
			"description": "The EXECUTE statement enables a QMBasic program to execute any command. The synonym PERFORM can be used in place of EXECUTE."
		},
		"PRINTER": {
			"prefix": "PRINTER",
			"body": "PRINTER $ON_OFF_CLOSE",
			"description": "The PRINTER ON and OFF statements determine whether output from PRINT statements to the default print unit (unit 0) is directed to the display or to the printer."
		},
		"PRINTERR": {
			"prefix": "PRINTERR",
			"body": "PRINTERR $expression",
			"description": "The PRINTERR statement displays an error message which is removed from the screen when the next input is entered."
		},
		"QUOTES": {
			"prefix": "QUOTES",
			"body": "QUOTE($expression)",
			"description": "The QUOTE() function returns a copy of its argument string enclosed in double quotes. The DQUOTE() synonym is identical. The QUOTES() and DQUOTES() functions are similar but operate on successive elements of a dynamic array, returning a similarly structured dynamic array of results."
		},
		"READ All": {
			"prefix": "READ",
			"body": [
				"READ $var ENCODING $name FROM $filevar,$recordkey ON ERROR $statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READ statement reads a record from a previously opened file."
		},
		"READL All": {
			"prefix": "READL",
			"body": [
				"READL $var ENCODING $name FROM $filevar,$recordkey ON ERROR $statement LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": ""
		},
		"READNEXT All": {
			"prefix": "READNEXT",
			"body": [
				"READNEXT $var, $valpos, $subvalpos FROM $list ON ERROR $err_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READNEXT statement returns the next item from an active select list."
		},
		"READU All": {
			"prefix": "READU",
			"body": [
				"READU $var ENCODING $name FROM $filevar,$recordkey ON ERROR $error_statements LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READU statement reads a record from a previously opened file, setting an update lock."
		},
		"READV All": {
			"prefix": "READV",
			"body": [
				"READV $var ENCODING $name FROM $filevar,$recordkey,$attr ON ERROR $error_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READV statement reads a specific field from a record of a previously opened file."
		},
		"READVL All": {
			"prefix": "READVL",
			"body": [
				"READVL $var ENCODING $name FROM $filevar,$recordkey,$attr ON ERROR $error_statements LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READVL statement reads a specific field from a record of a previously opened file, setting a read lock. The READVU statement is similar but sets an update lock."
		},
		"READVU All": {
			"prefix": "READVU",
			"body": [
				"READVU $var ENCODING $name FROM $filevar,$recordkey,$attr ON ERROR $error_statements LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The READVL statement reads a specific field from a record of a previously opened file, setting a read lock. The READVU statement is similar but sets an update lock."
		},
		"REM Comment": {
			"prefix": "REM",
			"body": "REM $text",
			"description": "The REMARK statement, which may be abbreviated to REM, enters comment text into a program."
		},
		"REMOVE Statement": {
			"prefix": "REMOVE",
			"body": "REMOVE $str FROM $array SETTING $setvar",
			"description": "The REMOVE statement and REMOVE() function extract characters from a dynamic array up to the next mark character."
		},
		"REMOVE Function": {
			"prefix": "REMOVE",
			"body": "REMOVE($array, $var)",
			"description": "The REMOVE statement and REMOVE() function extract characters from a dynamic array up to the next mark character."
		},
		"SELECTN": {
			"prefix": "SELECTN",
			"body": "SELECTN $variable1 TO $list ON ERROR $err_statements",
			"description": "The SELECT statement creates a select list containing all record keys from a file."
		},
		"SELECTV": {
			"prefix": "SELECTV",
			"body": "SELECTV $variable1 TO $list ON ERROR $err_statements",
			"description": "The SELECT statement creates a select list containing all record keys from a file."
		},
		"STATUS Function": {
			"prefix": "STATUS",
			"body": "STATUS()",
			"description": "The STATUS() function returns information following execution of certain other statements. In many cases, this information gives details of an error condition."
		},
		"STATUS Statement": {
			"prefix": "STATUS",
			"body": [
				"STATUS $array FROM $variable THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The STATUS statement returns a dynamic array containing a variety of information about an open file."
		},
		"SUBROUTINE Skeleton": {
			"prefix": "SUB",
			"body": [
				"SUBROUTINE $1($2)",
				"*-----",
				"* Description : $3",
				"* Author  : $4",
				"* Date: $5",
				"*-----",
				" \\$INCLUDE Common",
				"*-----",
				" Gosub Initialise",
				"*-----",
				"  $6",
				"*-----",
				"ExitProgram:",
				"*-----",
				" Return",
				" End",
				"*-----",
				"Initialise:",
				"*-----",
				"",
				" Return"
			],
			"description": ""
		},
		"TOTAL": {
			"prefix": "TOTAL",
			"body": "TOTAL($expr)",
			"description": "The TOTAL() function accumulates totals for use with the CALC query processor keyword. It is only available in dictionary I-type items."
		},
		"XTRANS": {
			"prefix": "XTRANS",
			"body": "XTRANS($filename, $key, $field, $actioncode)",
			"description": "The TRANS() function returns a field or the entire record from a named data file. It is normally only used in dictionary I-type items. The synonym XLATE() may be used."
		},
		"TRY \/ CATCH": {
			"prefix": "TRY",
			"body": [
				"TRY",
				"\t$statements",
				"CATCH $exception $qualifiers",
				"\t$catch_statements",
				"END"
			],
			"description": "The TRY\/CATCH construct allows creation of exception handlers in a manner broadly similar to that of some other programming languages."
		},
		"UNTIL LOOP (Modern)": {
			"prefix": "LOOP",
			"body": [
				"LOOP UNTIL $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The LOOP statement introduces a sequence of statements to be executed repeatedly."
		},
		"WHILE LOOP (Modern)": {
			"prefix": "LOOP",
			"body": [
				"LOOP WHILE $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The LOOP statement introduces a sequence of statements to be executed repeatedly."
		},
		"WRITE All": {
			"prefix": "WRITE",
			"body": "WRITE $var ENCODING $name TO $filevar CREATING.SEQKEY $idvar ON ERROR $error_statements",
			"description": "The WRITE statement writes a record to a previously opened file. The WRITEU statement is identical but preserves any lock on the record."
		},
		"WRITEU All": {
			"prefix": "WRITEU",
			"body": "WRITEU $var ENCODING $name TO $filevar CREATING.SEQKEY $idvar ON ERROR $error_statements",
			"description": "The WRITE statement writes a record to a previously opened file. The WRITEU statement is identical but preserves any lock on the record."
		},
		"WRITEV All": {
			"prefix": "WRITEV",
			"body": "WRITEV $var ENCODING $name TO $filevar,$recordkey,$attr ON ERROR $error_statements",
			"description": "The WRITEV statement writes a specific field to a record of a previously opened file. The WRITEVU statement is identical but preserves any lock on the record."
		},
		"WRITEVU All": {
			"prefix": "WRITEVU",
			"body": "WRITEVU $var ENCODING $name TO $filevar,$recordkey,$attr ON ERROR $error_statements",
			"description": "The WRITEV statement writes a specific field to a record of a previously opened file. The WRITEVU statement is identical but preserves any lock on the record."
		}
	},
	"UniData": {
		"acceptConnection": {
			"prefix": "acceptConnection($svr_socket, $blocking_mode, $timeout, $in_addr, $in_name, $socket_handle)",
			"body": "acceptConnection",
			"description": "Use the acceptConnection() function to accept an incoming connection attempt on the server side socket."
		},
		"addAuthenticationRule": {
			"prefix": "addAuthenticationRule",
			"body": "addAuthenticationRule($context, $serverOrClient, $rule, $ruleString)",
			"description": "The addAuthenticationRule function adds an authentication rule to a security context. The rules are used during SSL negotiation to determine whether or not the peer is to be trusted."
		},
		"addCertificate": {
			"prefix": "addCertificate",
			"body": "addCertificate($certPath, $usedAs, $format, $algorithm, $context)",
			"description": "The addCertificate function loads a certificate, or multiple certificates, into a security context for UniData to use as a server or client certificate. Alternatively, this function can specify a directory which contains the certificates that are either used as CA (Certificate Authority) certificates to authenticate incoming certificates, or act as a Revocation list to check against expired or revoked certificates."
		},
		"addRequestParameter": {
			"prefix": "addRequestParameter",
			"body": "addRequestParameter($request_handle, $parameter_name, $parameter_value, $content_handling)",
			"description": "The addRequestParameter function adds a parameter to the request."
		},
		"amInitialize": {
			"prefix": "amInitialize",
			"body": "amInitialize($hSession, $appName, $policyName, $reasonCode)",
			"description": "The amInitialize function creates and opens an AMI session. The output parameter, hsession, is a session handle that is valid until the session is terminated. This function returns a status code indicating success, warning, or failure."
		},
		"amReceiveMsg": {
			"prefix": "amReceiveMsg",
			"body": "amReceiveMsg($hSession, $receiverName, $policyName, $selMsgName, $maxMsgLen, $dataLen, $data, $rcvMsgName, $reasonCode)",
			"description": "The amReceiveMsg function receives a message sent by the amSendMsg function. For detailed information about amReceiveMsg, see UniBasic Extensions."
		},
		"amReceiveRequest": {
			"prefix": "amReceiveRequest",
			"body": "amReceiveRequest($hSession, $receiverName, $policyName, $maxMsgLen, $dataLen, $data, $rcvMsgName, $senderName, $reasonCode)",
			"description": "The amReceiveRequest function receives a request message. For detailed information about this function, see UniBasic Extensions."
		},
		"amSendMsg": {
			"prefix": "amSendMsg",
			"body": "amSendMsg($hSession, $senderName, $policyName, $data, $sndMsgName, $reasonCode)",
			"description": "The amSendMsg function sends a datagram (send and forget) message. For detailed information about this function, see UniBasic Extensions."
		},
		"amSendRequest": {
			"prefix": "amSendRequest",
			"body": "amSendRequest($hSession, $senderName, $policyName, $data, $sndMsgName, $reasonCode)",
			"description": "The amSendRequest function sends a request message."
		},
		"amSendResponse": {
			"prefix": "amSendResponse",
			"body": "amSendResponse($hSession, $senderName, $policyName, $rcvMsgName, $data, $sndMsgName, $reasonCode)",
			"description": "The amSendResponse function sends a request message."
		},
		"amTerminate": {
			"prefix": "amTerminate",
			"body": "amTerminate($hSession, $policyName, $reasonCode)",
			"description": "The amTerminate function closes a session."
		},
		"analyzeCertificate": {
			"prefix": "analyzeCertificate",
			"body": "analyzeCertificate($cert, $format, $result)",
			"description": "The analyzeCertficate function decodes a certificate and inputs plain text in the result parameter. The result parameter then contains such information as the subject name, location, institute, issuer, public key, other extensions, and the signature of the issuer."
		},
		"closeSocket": {
			"prefix": "closeSocket",
			"body": "closeSocket($socket_handle)",
			"description": "Use the closeSocket() function to close a socket connection."
		},
		"CONVERT Function": {
			"prefix": "CONVERT",
			"body": "CONVERT($fromchars, $tostring, $var)",
			"description": "The UniBasic CONVERT function changes all occurrences of the substring expr1 in expr3 to the string expr2. The system compares each character of the replacement string expr2 and, if necessary, replaces each character of the target string expr1 on an individual basis. UniBasic does not compare and insert strings as a whole. CONVERT supports multibyte languages."
		},
		"CONVERT Statement": {
			"prefix": "CONVERT",
			"body": "CONVERT $fromchars TO $tostring IN $var",
			"description": "The UniBasic CONVERT command changes all occurrences of the substring expr1 in var to the string expr2. UniBasic compares each character of the replacement string expr2 and, if necessary, replaces each character of the target string expr1 on an individual basis. UniBasic does not compare and insert strings as a whole. CONVERT supports multibyte languages."
		},
		"createCertificate": {
			"prefix": "createCertificate",
			"body": "createCertificate($action, $req, $signKey, $keyPass, $CAcert, $days, $extensions, $certOut)",
			"description": "The createCertificate function generates a certificate. The certificate can either be a selfsigned certificate as a root CA that you can use later to sign other certificates, or it can be a CA signed certificate. The generated certificate conforms to X509V3 standard."
		},
		"createCertRequest": {
			"prefix": "createCertRequest",
			"body": "createCertRequest($key, $inFormat, $keyLoc, $algorithm, $digest, $passPhrase, $subjectData, $outFile, $outFormat)",
			"description": "The createCertRequest() function generates a PKCS #10 certificate request from a private key in PKCS #8 form and a set of user specified data. The request can be sent to a CA or used as a parameter to createCertificate() to obtain an X.509 public key certificate."
		},
		"createRequest": {
			"prefix": "createRequest",
			"body": "createRequest($URL, $http_method, $request_handle)",
			"description": "The createRequest function creates an HTTP request and returns a handle to the request."
		},
		"createSecureRequest": {
			"prefix": "createSecureRequest",
			"body": "createSecureRequest($URL, $http_method, $request_handle, $security_context)",
			"description": "The createSecureRequest function behaves exactly the same as the createRequest() function, except for the fourth parameter, a handle to a security context, which is used to associate the security context with the request. If the URL does not start with \u201chttps\u201d the parameter is ignored. If the URL starts with \u201chttps\u201d but an invalid context handle or no handle is provided, the function aborts and returns with an error status."
		},
		"createSecurityContext": {
			"prefix": "createSecurityContext",
			"body": "createSecurityContext($context, $version)",
			"description": "The createSecurityContext function creates a security context and returns a handle to the context."
		},
		"DELETE Function": {
			"prefix": "DELETE",
			"body": "DELETE($arr, $attr, $val, $subval)",
			"description": "The UniBasic DELETE command deletes a record from a UniData file. In addition, the DELETE command releases any locks on the record that have been set by previous commands."
		},
		"DELETE Statement": {
			"prefix": "DELETE",
			"body": "DELETE $filevar,$recordkey",
			"description": "The UniBasic DELETE command deletes a record from a UniData file. In addition, the DELETE command releases any locks on the record that have been set by previous commands."
		},
		"generateKey": {
			"prefix": "generateKey",
			"body": "generateKey($priveKey, $pubKey, $format, $keyLoc, $algorithm, $keyLength, $passPhrase, $paramFile)",
			"description": "The generateKey() function generates a public key cryptography key pair and encrypts the private key. You should then put it into an external key file protected by the provided pass phrase. UniData SSL sessions can use the protected private key later to secure communication. The public key will not be encrypted."
		},
		"getCipherSuite": {
			"prefix": "getCipherSuite",
			"body": "getCipherSuite($context, $ciphers)",
			"description": "The getCipherSuite() function obtains information about supported cipher suites, their version, usage, strength and type for the security context you specify."
		},
		"getHTTPDefault": {
			"prefix": "getHTTPDefault",
			"body": "getHTTPDefault($option, $value)",
			"description": "The getHTTPDefault function returns the default values of the HTTP settings."
		},
		"getIpv": {
			"prefix": "getIpv",
			"body": "getIpv($opt, $sockettype)",
			"description": "The getIpv function, without an option, returns the current IPv setting. If a network choice is entered as an option, it returns only that network\u2019s IPv setting."
		},
		"getResponseHeader": {
			"prefix": "getResponseHeader",
			"body": "getResponseHeader($request_handle, $header_name, $header_value)",
			"description": "This function gets a specific response header value from response headers returned by submitRequest(). It can be used to query if a specific header, for example, Content-encoding, is present in the response."
		},
		"getSocketErrorMessage": {
			"prefix": "getSocketErrorMessage",
			"body": "getSocketErrorMessage($errCode, $errMsg)",
			"description": "Use the getSocketErrorMessage() function to translate an error code into a text error message."
		},
		"getSocketInformation": {
			"prefix": "getSocketInformation",
			"body": "getSocketInformation($socket_handle, $self_ or_ peer, $socket_info)",
			"description": "Use the getSocketInformation() function to obtain information about a socket connection."
		},
		"getSocketOptions": {
			"prefix": "getSocketOptions",
			"body": "getSocketOptions($socket_handle, $options)",
			"description": "The getSocketOptions() function gets the current value for a socket option associated with a socket of any type."
		},
		"HMAC function": {
			"prefix": "HMAC function",
			"body": "HMAC($hmacAlg, $hmacKey, $hmacData, $outFormat)",
			"description": "HMAC (keyed-Hash Message Authentication Code) is a specific construction for calculating a message authentication code (MAC) involving a cryptographic hash function in combination with a secret key."
		},
		"IF Then": {
			"prefix": "IF",
			"body": [
				"IF $1 THEN",
				"\t$2",
				"END"
			],
			"description": "The UniBasic IF\/THEN\/ELSE command executes one of two blocks of statements based on a conditional expression. If expr is true, UniData executes the first group of statements. If expr is false, UniData executes the second group of statements."
		},
		"IF Then\/Else": {
			"prefix": "IF",
			"body": [
				"IF $1 THEN",
				"\t$2",
				"END ELSE",
				"\t$3",
				"END"
			],
			"description": "The UniBasic IF\/THEN\/ELSE command executes one of two blocks of statements based on a conditional expression. If expr is true, UniData executes the first group of statements. If expr is false, UniData executes the second group of statements."
		},
		"initSecureServerSocket": {
			"prefix": "initSecureServerSocket",
			"body": "initSecureServerSocket($name_or_IP, $port, $backlog, $svr_socket, $context)",
			"description": "Use the initSecureServerSocket() function to create a secured connection-oriented stream server socket. It does exactly the same as the initServerSocket() function except that the connection will be secure."
		},
		"initServerSocket": {
			"prefix": "initServerSocket",
			"body": "initServerSocket($name_or_IP, $port, $backlog, $svr_socket)",
			"description": "Use the initServerSocket() function to create a connection-oriented (stream) socket. Associate this socket with an address (name_or_IP) and port number (port), and specify the maximum length the queue of pending connections may grow to."
		},
		"loadSecurityContext": {
			"prefix": "loadSecurityContext",
			"body": "loadSecurityContext($context, $name, $passPhrase)",
			"description": "The loadSecurityContext() function loads a saved security context record into the current session."
		},
		"LOCATE Function": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE($search, $subject; $returnVar) THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The UniBasic LOCATE command locates an element within a dynamic array. For LOCATE to be successful, the search string, element, must match the entire array element (including any associated lower-level elements). LOCATE does not modify the data in the array."
		},
		"LOCATE Statement": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE $search IN $subject SETTING $returnVar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The UniBasic LOCATE command locates an element within a dynamic array. For LOCATE to be successful, the search string, element, must match the entire array element (including any associated lower-level elements). LOCATE does not modify the data in the array."
		},
		"LOOP While": {
			"prefix": "LOOP",
			"body": [
				"LOOP",
				"\t$statement1",
				"WHILE $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The UniBasic LOOP\/REPEAT command repeats any contained statements while or until a specified condition is met, depending on whether you use the WHILE or UNTIL clause. statements can precede and\/or follow the test condition. If space permits, you can write the structure on one line. Otherwise, you can extend the structure on as many lines as necessary. REPEAT is required and finishes the LOOP operation."
		},
		"LOOP Until": {
			"prefix": "LOOP",
			"body": [
				"LOOP",
				"\t$statement1",
				"UNTIL $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The UniBasic LOOP\/REPEAT command repeats any contained statements while or until a specified condition is met, depending on whether you use the WHILE or UNTIL clause. statements can precede and\/or follow the test condition. If space permits, you can write the structure on one line. Otherwise, you can extend the structure on as many lines as necessary. REPEAT is required and finishes the LOOP operation."
		},
		"WHILE LOOP (Modern)": {
			"prefix": "LOOP",
			"body": [
				"LOOP WHILE $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The UniBasic LOOP\/REPEAT command repeats any contained statements while or until a specified condition is met, depending on whether you use the WHILE or UNTIL clause. statements can precede and\/or follow the test condition. If space permits, you can write the structure on one line. Otherwise, you can extend the structure on as many lines as necessary. REPEAT is required and finishes the LOOP operation."
		},
		"UNTIL LOOP (Modern)": {
			"prefix": "LOOP",
			"body": [
				"LOOP UNTIL $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "The UniBasic LOOP\/REPEAT command repeats any contained statements while or until a specified condition is met, depending on whether you use the WHILE or UNTIL clause. statements can precede and\/or follow the test condition. If space permits, you can write the structure on one line. Otherwise, you can extend the structure on as many lines as necessary. REPEAT is required and finishes the LOOP operation."
		},
		"openSecureSocket": {
			"prefix": "openSecureSocket",
			"body": "openSecureSocket($name_or_IP, $port, $mode, $timeout, $socket_handle, $context)",
			"description": "Use the openSecureSocket() function to open a secure socket connection in a specified mode and return the status."
		},
		"openSocket": {
			"prefix": "openSocket",
			"body": "openSocket($name_or_IP, $port, $mode, $timeout, $socket_handle)",
			"description": "Use the openSocket() function to open a socket connection in a specified mode and return the status."
		},
		"protocolLogging": {
			"prefix": "protocolLogging",
			"body": "protocolLogging($log_file, $log_action, $log_level)",
			"description": "This function will start or stop logging."
		},
		"readSocket": {
			"prefix": "readSocket",
			"body": "readSocket($socket_handle, $socket_data, $max_read_size, $time_out, $mode, $actual_read_size)",
			"description": "Use the readSocket() function to read data in the socket buffer up to max_read_size characters."
		},
		"REMOVE Function": {
			"prefix": "REMOVE",
			"body": "REMOVE($dynarr, $delim)",
			"description": "The UniBasic REMOVE function extracts an element from a dynamic array and assigns the removed element to a variable. REMOVE does not change the value of the dynamic array."
		},
		"saveSecurityContext": {
			"prefix": "saveSecurityContext",
			"body": "saveSecurityContext($context, $name, $passPhrase)",
			"description": "The saveSecurityContext() function encrypts and saves a security context to a system security file. UniData maintains this file on a per account basis for. and uses the name as the record ID to access the saved security information. Since the information is encrypted, you should not attempt to directly manipulate the information."
		},
		"setAuthenticationDepth": {
			"prefix": "setAuthenticationDepth",
			"body": "setAuthenticationDepth($context, $depth, $serverOrClient)",
			"description": "The setAuthenticationDepth() function sets how deeply UniData should verify before deciding that a certificate is not valid."
		},
		"setCipherSuite": {
			"prefix": "setCipherSuite",
			"body": "setCipherSuite($context, $cipherSpecs)",
			"description": "The setCipherSuite() function enables you to identify which cipher suites to support for the specified context. It affects the cipher suites and public key algorithms supported during the SSL\/TLS handshake and subsequent data exchanges."
		},
		"setClientAuthentication": {
			"prefix": "setClientAuthentication",
			"body": "setClientAuthentication($context, $option)",
			"description": "The setClientAuthentication() function turns client authentication for a server socket on or off. When option is set to on, during the initial SSL handshake, the server sends a client authentication request to the client. It will also receive the client certificate and perform authentication according to the issuer\u2019s certificate (or certificate chain) set in the security context."
		},
		"setHTTPDefault": {
			"prefix": "setHTTPDefault",
			"body": "setHTTPDefault($opt, $val)",
			"description": "The setHTTPDefault function configures the default HTTP settings, including proxy server and port, buffer size, authentication credential, HTTP version, and request header values. UniBasic uses these settings with every HTTP request that follows."
		},
		"setIpv": {
			"prefix": "setIpv",
			"body": "setIpv($opt, $sockettype)",
			"description": "The setIpv function configures which IP setting to use; IPv4 or IPv6. If the machine is IPv6 enabled, all server side sockets will use IPv6, which can accept client connections on both IPv4 and IPv6. If the machine is not IPv6 enabled, server and client will remain working on IPv4. This function can accept one or two options. For example, setIpv(IPV6) or setIpv(IPV6,SOCKET)."
		},
		"setPrivateKey": {
			"prefix": "setPrivateKey",
			"body": "setPrivateKey($key, $format, $keyLoc, $passPhrase, $validate, $context)",
			"description": "The setPrivateKey() function loads the private key into a security context so that it can be used by SSL functions. If the context already had a set private key, it will be replaced."
		},
		"setRandomSeed": {
			"prefix": "setRandomSeed",
			"body": "setRandomSeed($inFiles, $outFile, $length, $context)",
			"description": "The setRandomSeed() function generates a random seed file from a series of source files and sets that file as the default seed file for the supplied security context."
		},
		"setRequestHeader": {
			"prefix": "setRequestHeader",
			"body": "setRequestHeader($request_handle, $header_name, $header_value)",
			"description": "The setRequestHeader function allows the user to set additional headers for a request."
		},
		"setSocketOptions": {
			"prefix": "setSocketOptions",
			"body": "setSocketOptions($socket_handle, $options)",
			"description": "The setSocketOptions() function sets the current value for a socket option associated with a socket of any type."
		},
		"showSecurityContext": {
			"prefix": "showSecurityContext",
			"body": "showSecurityContext($context, $config)",
			"description": "The showSecurityContext() function dumps the SSL configuration parameters of a security context into a readable format."
		},
		"SOAPCreateRequest": {
			"prefix": "SOAPCreateRequest",
			"body": "SOAPCreateRequest($URL, $soapAction, $Request)",
			"description": "Creates a SOAP request and returns a handle to the request."
		},
		"SOAPCreateSecureRequest": {
			"prefix": "SOAPCreateSecureRequest",
			"body": "SOAPCreateSecureRequest($URL, $soapAction, $Request, $security_context)",
			"description": "The SOAPCreateSecureRequest function creates a secure SOAP request and returns a handle to the request."
		},
		"SOAPGetDefault": {
			"prefix": "SOAPGetDefault",
			"body": "SOAPGetDefault($option, $value)",
			"description": "Gets default SOAP settings, such as the SOAP version."
		},
		"SOAPGetFault": {
			"prefix": "SOAPGetFault",
			"body": "SOAPGetFault($respData, $soapFault)",
			"description": "Parses the response data from SOAPSubmitRequest after receiving a SOAP Fault, into a dynamic array of SOAP Fault components."
		},
		"SOAPGetResponseHeader": {
			"prefix": "SOAPGetResponseHeader",
			"body": "SOAPGetResponseHeader($Request, $headerName, $headerValue)",
			"description": "Gets a specific response header after issuing a SOAP request."
		},
		"SOAPRequestWrite": {
			"prefix": "SOAPRequestWrite",
			"body": "SOAPRequestWrite($Request, $reqDoc, $docTypeFlag)",
			"description": "Outputs the SOAP request in XML format to a string or to a file."
		},
		"SOAPSetDefault": {
			"prefix": "SOAPSetDefault",
			"body": "SOAPSetDefault($option, $value)",
			"description": "Setup default SOAP settings, such as SOAP version."
		},
		"SOAPSetParameters": {
			"prefix": "SOAPSetParameters",
			"body": "SOAPSetParameters($Request, $URI, $serviceName, $value)",
			"description": "Sets up the SOAP request body, specifying a remote method to call along with the method's parameter list."
		},
		"SOAPSetRequestBody": {
			"prefix": "SOAPSetRequestBody",
			"body": "SOAPSetRequestBody($Request, $value)",
			"description": "Sets up a SOAP request body directly, as opposed to having it be constructed through the SOAPSetParameters function. With this function it also possible to attach multiple body blocks to the SOAP request."
		},
		"SOAPSetRequestContent": {
			"prefix": "SOAPSetRequestContent",
			"body": "SOAPSetRequestContent($Request, $reqDoc, $docTypeFlag)",
			"description": "Sets the entire SOAP request's content from an input string or from a file."
		},
		"SOAPSetRequestHeader": {
			"prefix": "SOAPSetRequestHeader",
			"body": "SOAPSetRequestHeader($Request, $value)",
			"description": "Sets up a SOAP request header. By default, there is no SOAP header."
		},
		"SOAPSubmitRequest": {
			"prefix": "SOAPSubmitRequest",
			"body": "SOAPSubmitRequest($Request, $timeout, $respHeaders, $respData, $soapStatus)",
			"description": "Submits a request and gets the response."
		},
		"SQLAllocConnect": {
			"prefix": "SQLAllocConnect",
			"body": "SQLAllocConnect($bcienv, $connectenv)",
			"description": "SQLAllocConnect allocates and initializes a connection environment in a UniData BCI environment."
		},
		"SQLAllocEnv": {
			"prefix": "SQLAllocEnv",
			"body": "SQLAllocEnv($bcienv)",
			"description": "SQLAllocEnv creates an environment in which to execute UniData BCI calls."
		},
		"SQLAllocStmt": {
			"prefix": "SQLAllocStmt",
			"body": "SQLAllocStmt($connect.env, $statement.env)",
			"description": "SQLAllocStmt creates an SQL statement environment in which to execute SQL statements."
		},
		"SQLBindCol": {
			"prefix": "SQLBindCol",
			"body": "SQLBindCol($statementenv, $col, $datatype, $column)",
			"description": "Use this function to tell UniData BCI where to return the results of an SQLFetch call. SQLBindCol defines the name of the variable (column) to contain column results retrieved by SQLFetch, and specifies the data conversion (data.type) on the fetched data. SQLBindCol has no effect until SQLFetch is used."
		},
		"SQLBindParameter": {
			"prefix": "SQLBindParameter",
			"body": "SQLBindParameter($statementenv, $mrk, $datatype, $sqltype, $prec, $scale, $param, $paramtype)",
			"description": "SQLBindParameter specifies where to find values for input parameter markers when you issue an SQLExecute or SQLExecDirect call. For output parameter markers, SQLBindParameter specifies where to find the return value of a called procedure."
		},
		"SQLCancel": {
			"prefix": "SQLCancel",
			"body": "SQLCancel($statementenv)",
			"description": "This function is equivalent to the SQLFreeStmt call with the SQL.CLOSE option. It closes any open cursor associated with the SQL statement environment and discards pending results at the data source."
		},
		"SQLColAttributes": {
			"prefix": "SQLColAttributes",
			"body": "SQLColAttributes($statementenv, $col, $colattr, $textvar, $numvar)",
			"description": "Use this function to get information about a column. SQLColAttributes returns the specific information requested by the value of col.attribute."
		},
		"SQLColumns": {
			"prefix": "SQLColumns",
			"body": "SQLColumns($statementenv, $schema, $owner, $tablename, $columnname)",
			"description": "This function returns a result set in statement.env as a cursor of 12 columns describing those columns found by the search pattern (see SQLTables). As with SQLTables, the search is done on the SQL catalog. This is a standard result set that can be accessed with SQLFetch. The ability to obtain descriptions of columns does not imply that a user has any privileges on those columns."
		},
		"SQLConnect": {
			"prefix": "SQLConnect",
			"body": "SQLConnect($connectenv, $datasource, $login1, $login2)",
			"description": "Use this function to connect to the ODBC data source specified by data.source. Use the login1 and login2 parameters to log in to the DBMS specified by the ODBC data.source."
		},
		"SQLDescribeCol": {
			"prefix": "SQLDescribeCol",
			"body": "SQLDescribeCol($statementenv, $col, $colname, $sqltype, $prec, $scale, $null)",
			"description": "Use this function to get information about the column described by col#."
		},
		"SQLDisconnect": {
			"prefix": "SQLDisconnect",
			"body": "SQLDisconnect($connectenv)",
			"description": "SQLDisconnect disconnects a connection environment from a data source."
		},
		"SQLError": {
			"prefix": "SQLError",
			"body": "SQLError($bcienv, $connectenv, $statementenv, $sqlstate, $dbmscode, $error)",
			"description": "SQLError returns error status information about one of the three environments you use."
		},
		"SQLExecDirect": {
			"prefix": "SQLExecDirect",
			"body": "SQLExecDirect($statementenv, $statement)",
			"description": "SQLExecDirect accepts an SQL statement or procedure call and delivers it to the data source for execution. It uses the current values of any SQL statement parameter markers."
		},
		"SQLExecute": {
			"prefix": "SQLExecute",
			"body": "SQLExecute($statementenv)",
			"description": "Use this function to repeatedly execute an SQL statement, using different values for parameter markers. You must use an SQLPrepare call to prepare the SQL statement before you can use SQLExecute. If the SQL statement specified in the SQLPrepare call contains parameter markers, you must also issue an SQLBindParameter call for each marker in the SQL statement before you use SQLExecute. After you load the parameter marker variables with data to send to the data source, you can issue the SQLExecute call. By setting new values in the parameter marker variables and calling SQLExecute, new data values are sent to the data source and the SQL statement is executed using those values"
		},
		"SQLFetch": {
			"prefix": "SQLFetch",
			"body": "SQLFetch($statementenv)",
			"description": "Use this function to retrieve the next row\u2019s column values from the result set at the data source and put them into the variables specified with SQLBindCol. SQLFetch performs any required data conversions."
		},
		"SQLFreeConnect": {
			"prefix": "SQLFreeConnect",
			"body": "SQLFreeConnect($connectenv)",
			"description": "SQLFreeConnect releases a connection environment and its resources. You must use SQLDisconnect to disconnect the connection environment from the data source before you release the connection environment with SQLFreeConnect, otherwise an error is returned."
		},
		"SQLFreeEnv": {
			"prefix": "SQLFreeEnv",
			"body": "SQLFreeEnv($bcienv)",
			"description": "SQLFreeEnv releases an SQL Client Interface environment and its resources. You must use SQLFreeConnect to release all connection environments attached to the UniData BCI environment before you release the UniData BCI environment with SQLFreeEnv, otherwise an error is returned."
		},
		"SQLFreeStmt": {
			"prefix": "SQLFreeStmt",
			"body": "SQLFreeStmt($statementenv, $option)",
			"description": "SQLFreeStmt frees some or all resources associated with an SQL statement environment."
		},
		"SQLGetInfo": {
			"prefix": "SQLGetInfo",
			"body": "SQLGetInfo($connectenv, $infotype, $infovalue)",
			"description": "SQLGetInfo returns general information about the ODBC driver and the data source. This function supports all of the possible requests for information defined in the ODBC 2.0 specification. The #defines for info.type are contained in the ODBC.H include file."
		},
		"SQLGetTypeInfo": {
			"prefix": "SQLGetTypeInfo",
			"body": "SQLGetTypeInfo($statementenv, $sqltype)",
			"description": "SQLGetTypeInfo returns information about an SQL on the data source. You can use SQLGetTypeInfo only against ODBC data sources. SQLGetTypeInfo returns a standard result set ordered by DATA.TYPE and TYPE.NAME."
		},
		"SQLNumParams": {
			"prefix": "SQLNumParams",
			"body": "SQLNumParams($statementenv, $params)",
			"description": "SQLNumParams returns the number of parameters in an SQL statement. Use this function after preparing or executing an SQL statement or procedure call to find the number of parameters in an SQL statement. If the statement associated with statement.env contains no parameters, parameters is set to 0."
		},
		"SQLNumResultCols": {
			"prefix": "SQLNumResultCols",
			"body": "SQLNumResultCols($statementenv, $cols)",
			"description": "SQLNumResultCols returns the number of columns in a result set. Use this function after executing an SQL statement to find the number of columns in the result set. If the executed statement was not a SELECT statement or a called procedure that produced a result set, the number of result columns returned is 0. Use this function when the number of columns to be bound to application variables is unknown, for example, when your program is processing SQL statements entered by users."
		},
		"SQLParamOptions": {
			"prefix": "SQLParamOptions",
			"body": "SQLParamOptions($statementenv, $option, $value)",
			"description": "SQLParamOptions lets applications load an array of parameter markers in a single SQLExecDirect or SQLExecute function call. Use this function only when you are connected to an ODBC data source."
		},
		"SQLPrepare": {
			"prefix": "SQLPrepare",
			"body": "SQLPrepare($statementenv, $statement)",
			"description": "SQLPrepare passes an SQL statement or procedure call to the data source in order to prepare it for execution by SQLExecute."
		},
		"SQLRowCount": {
			"prefix": "SQLRowCount",
			"body": "SQLRowCount($statementenv, $rows)",
			"description": "SQLRowCount returns the number of rows changed by UPDATE, INSERT, or DELETE statements, or by a called procedure that executes one of these statements."
		},
		"SQLSetConnectOption": {
			"prefix": "SQLSetConnectOption",
			"body": "SQLSetConnectOption($connectenv, $option, $value)",
			"description": "SQLSetConnectOption controls some aspects of the connection to a data source."
		},
		"SQLSetParam": {
			"prefix": "SQLSetParam",
			"body": "SQLSetParam($statementenv, $mrk, $datatype, $sqltype, $prec, $scale, $param, $paramtype)",
			"description": "SQLSetParam is a synonym for SQLBindParameter."
		},
		"SQLSpecialColumns": {
			"prefix": "SQLSpecialColumns",
			"body": "SQLSpecialColumns($statementenv, $coltype, $schema, $owner, $tablename, $IDscope, $null)",
			"description": "SQLSpecialColumns gets information about columns in a table."
		},
		"SQLStatistics": {
			"prefix": "SQLStatistics",
			"body": "SQLStatistics($statementenv, $schema, $owner, $tablename, $indextype, $accuracy)",
			"description": "SQLStatistics gets a list of statistics about a single table and its indexes. Use this function only when you are connected to an ODBC data source. SQLStatistics returns information as a standard result set ordered by NON.UNIQUE, TYPE, INDEX.QUALIFIER, INDEX.NAME, and SEQ.IN.INDEX. The result set combines statistics for the table with statistics for each index."
		},
		"SQLTables": {
			"prefix": "SQLTables",
			"body": "SQLTables($statementenv, $schema, $owner, $tablename, $type)",
			"description": "SQLTables returns a result set listing the tables matching the search patterns. Use this function only when you are connected to an ODBC data source."
		},
		"SQLTransact": {
			"prefix": "SQLTransact",
			"body": "SQLTransact($bcienv, $connectenv, $type)",
			"description": "SQLTransact requests a COMMIT or ROLLBACK for all SQL statements associated with a connection or all connections associated with an environment. Use this function only when you are connected to an ODBC data source."
		},
		"submitRequest": {
			"prefix": "submitRequest",
			"body": "submitRequest($request_handle, $time_out, $post_data, $response_headers, $response_data, $http_status)",
			"description": "The submitRequest function submits a request and gets a response."
		},
		"SUBROUTINE Skeleton": {
			"prefix": "SUB",
			"body": [
				"SUBROUTINE $1($2)",
				"*-----",
				"* Description : $3",
				"* Author  : $4",
				"* Date: $5",
				"*-----",
				" \\$INCLUDE Common",
				"*-----",
				" Gosub Initialise",
				"*-----",
				"  $6",
				"*-----",
				"ExitProgram:",
				"*-----",
				" Return",
				" End",
				"*-----",
				"Initialise:",
				"*-----",
				"",
				" Return"
			],
			"description": "The UniBasic SUBROUTINE command determines the beginning of an external subroutine."
		},
		"UDOArrayAppendItem": {
			"prefix": "UDOArrayAppendItem",
			"body": "UDOArrayAppendItem($udoHandle, $value)",
			"description": "The UDOArrayAppendItem() function appends the item you specify to the UDO array."
		},
		"UDOArrayDeleteItem": {
			"prefix": "UDOArrayDeleteItem",
			"body": "UDOArrayDeleteItem($udoHandle, $index)",
			"description": "The UDOArrayDeleteItem() function deletes the array item you specify by its index."
		},
		"UDOArrayGetItem": {
			"prefix": "UDOArrayGetItem",
			"body": "UDOArrayGetItem($udoHandle, $index, $value, $value_type)",
			"description": "The UDOArrayGetItem() function returns a UDO array item by its index."
		},
		"UDOArrayGetNextItem": {
			"prefix": "UDOArrayGetNextItem",
			"body": "UDOArrayGetNextItem($udoHandle, $value, $type)",
			"description": "The UDOArrayGetNextItem() function returns the next UDO array item relative to the current position, which is the position of the array the last time it was accessed by this function. The initial position is 1."
		},
		"UDOArrayGetSize": {
			"prefix": "UDOArrayGetSize",
			"body": "UDOArrayGetSize($udoHandle, $size)",
			"description": "The UDOArrayGetSize() function gets the size of a UDO array."
		},
		"UDOArrayInsertItem": {
			"prefix": "UDOArrayInsertItem",
			"body": "UDOArrayInsertItem($udoHandle, $index, $value)",
			"description": "The UDOArrayInsertItem() function inserts a UDO array element at the position you specify by index."
		},
		"UDOArraySetItem": {
			"prefix": "UDOArraySetItem",
			"body": "UDOArraySetItem($udoHandle, $index, $value)",
			"description": "The UDOArraySetItem() function sets or inserts a UDO array element at the position you specify."
		},
		"UDOClone": {
			"prefix": "UDOClone",
			"body": "UDOClone($udoHandle, $newUdoHandle)",
			"description": "The UDOClone function clones a UDO object or array so that changes to the new object or array will not affect the original object."
		},
		"UDOCreate": {
			"prefix": "UDOCreate",
			"body": "UDOCreate($udoType, $udoHandle)",
			"description": "The UDOCreate function creates a UDO item of the type you specify."
		},
		"UDODeleteProperty": {
			"prefix": "UDODeleteProperty",
			"body": "UDODeleteProperty($udoHandle, $name)",
			"description": "The UDODeleteProperty function deletes a property from the UDO object."
		},
		"UDOFree": {
			"prefix": "UDOFree",
			"body": "UDOFree($udoHandle)",
			"description": "The UDOFree function forcefully removes a UDO object or array from memory."
		},
		"UDOGetLastError": {
			"prefix": "UDOGetLastError",
			"body": "UDOGetLastError($errorCode, $errorMessage)",
			"description": "If the previous UDO call returned UDO_ERROR, use the UDOGetLastError() function to return the error code and error message."
		},
		"UDOGetNextProperty": {
			"prefix": "UDOGetNextProperty",
			"body": "UDOGetNextProperty($udoHandle, $name, $value, $value_type)",
			"description": "The UDOGetNextProperty function provides a convenient way to walk through all the properties in a UDO object, without needing to know the property names in advance."
		},
		"UDOGetOption": {
			"prefix": "UDOGetOption",
			"body": "UDOGetOption($option, $value)",
			"description": "The UDOGetOption function gets the value of a UDO option."
		},
		"UDOGetProperty": {
			"prefix": "UDOGetProperty",
			"body": "UDOGetProperty($udoHandle, $name, $value, $value_type)",
			"description": "The UDOGetProperty function returns the value and type of property on the UDO object."
		},
		"UDOGetPropertyNames": {
			"prefix": "UDOGetPropertyNames",
			"body": "UDOGetPropertyNames($udoHandle, $udoArray)",
			"description": "The UDOGetPropertyNames function returns a UDO array that holds the names of all the properties in the UDO object."
		},
		"UDOGetType": {
			"prefix": "UDOGetType",
			"body": "UDOGetType($udoHandle, $type)",
			"description": "The UDOGetType() function gets the UDO value type of a UniBasic variable."
		},
		"UDOIsTypeOf": {
			"prefix": "UDOIsTypeOf",
			"body": "UDOIsTypeOf($udoHandle, $type)",
			"description": "The UDOIsTypeOf() function tests the UDO value type of a UniBasic variable."
		},
		"UDORead": {
			"prefix": "UDORead",
			"body": "UDORead($inputString, $inputType, $udoHandle)",
			"description": "The UDORead function creates a UDO object from a JSON string."
		},
		"UDOSetOption": {
			"prefix": "UDOSetOption",
			"body": "UDOSetOption($option, $value)",
			"description": "Sets the options for the UDO API."
		},
		"UDOSetProperty": {
			"prefix": "UDOSetProperty",
			"body": "UDOSetProperty($udoHandle, $name, $value, $type)",
			"description": "The UDOSetProperty function creates or updates a property on a UDO object."
		},
		"UDOWrite": {
			"prefix": "UDOWrite",
			"body": "UDOWrite($udoHandle, $outputType, $outputString)",
			"description": "Writes a UDO object in JSON format."
		},
		"writeSocket": {
			"prefix": "writeSocket",
			"body": "writeSocket($socket_handle, $socket_data, $time_out, $mode, $actual_write_size)",
			"description": "Use the writeSocket() function to write data to a socket connection."
		},
		"XDOMAddChild": {
			"prefix": "XDOMAddChild",
			"body": "XDOMAddChild($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag, $nodeType)",
			"description": "Finds the xpathString in the context xmlHandle in the DOM structure, and inserts a node as the last child of the found node. If the inserted node type is XDOM.ATTR.NODE, this node is inserted as an attribute."
		},
		"XDOMAppend": {
			"prefix": "XDOMAppend",
			"body": "XDOMAppend($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag)",
			"description": "Finds the xpathString in the context xmlHandle in the DOM structure, and inserts nodeHandle into the DOM structure as next sibling of the found node. If the inserted node type is XDOM.ATTR.NODE, this node is inserted as an attribute"
		},
		"XDOMClone": {
			"prefix": "XDOMClone",
			"body": "XDOMClone($xmlHandle, $newXmlHandle, $depth)",
			"description": "Duplicates the DOM subtree specified by xmlHandle to a new subtree specified by newXmlHandle. The duplicate node has no parent (parentNode returns null.). Cloning an element copies all attributes and their values, including those generated by the XML processor, to represent defaulted attributes, but this method does not copy any text it contains unless it is a deep clone, since the text is contained in a child Text node. Cloning any other type of node simply returns a copy of this node."
		},
		"XDOMClose": {
			"prefix": "XDOMClose",
			"body": "XDOMClose($domHandle)",
			"description": "XDOMClose frees the DOM structure."
		},
		"XDOMCreateNode": {
			"prefix": "XDOMCreateNode",
			"body": "XDOMCreateNode($xmlHandle, $nodeName, $nodeValue, $nodeType, $nodeHandle)",
			"description": "XDOMCreateNode creates a new node in the DOM structure."
		},
		"XDOMCreateRoot": {
			"prefix": "XDOMCreateRoot",
			"body": "XDOMCreateRoot($domHandle, $xmlOptions)",
			"description": "XDOMCreateRoot creates a new DOM structure with root only. You can use the result handle in other functions where a DOM handle or node handle is needed."
		},
		"XDOMEvaluate": {
			"prefix": "XDOMEvaluate",
			"body": "XDOMEvaluate($xmlHandle, $xpathString, $nsMap, $aValue)",
			"description": "XDOMEvaluate returns the value of the XPathString in the context xmlHandle in the DOM structure."
		},
		"XDOMGetAttribute": {
			"prefix": "XDOMGetAttribute",
			"body": "XDOMGetAttribute($nodeHandle, $attrName, $nodeHandle)",
			"description": "XDOMGetAttribute gets the node's attribute node, whose attribute name is attrName."
		},
		"XDOMGetChildNodes": {
			"prefix": "XDOMGetChildNodes",
			"body": "XDOMChildNodes($xmlHandle, $nodeListHandle)",
			"description": "The XDOMGetChildNodes function returns all child nodes of xmlHandle."
		},
		"XDOMGetElementById": {
			"prefix": "XDOMGetElementById",
			"body": "XDOMGetElementById($xmlHandle, $idstr, $nodeHandle)",
			"description": "The XDOMGetElementByld function finds the first element with the ID you specify."
		},
		"XDOMGetElementsByName": {
			"prefix": "XDOMGetElementsByName",
			"body": "XDOMGetElementsByName($xmlHandle, $namestrnodeListHandle)",
			"description": "The XDOMGetElementsByName function tries to find all elements with the name you specify."
		},
		"XDOMGetElementsByTag": {
			"prefix": "XDOMGetElementsByTag",
			"body": "XDOMGetElementsByTag($xmlHandle, $tagname, $nodeListHandle)",
			"description": "The XDOMGetElementsByTag function tries to find all elements with the tag name you specify."
		},
		"XDOMGetNodeName": {
			"prefix": "XDOMGetNodeName",
			"body": "XDOMGetNodeName($nodeHandle, $nodeName)",
			"description": "XDOMGetNodeName gets the node name."
		},
		"XDOMGetNodeType": {
			"prefix": "XDOMGetNodeType",
			"body": "XDOMGetNodeType($nodeHandle, $nodeType)",
			"description": "XDOMGetNodeType gets the node type."
		},
		"XDOMGetNodeValue": {
			"prefix": "XDOMGetNodeValue",
			"body": "XDOMGetNodeValue($nodeHandle, $nodeValue)",
			"description": "XDOMGetNodeValue gets the node value."
		},
		"XDOMGetOwnerDocument": {
			"prefix": "XDOMGetOwnerDocument",
			"body": "XDOMGetOwnerDocument($nodeHandle, $domHandle)",
			"description": "XDOMGetOwnerDocument gets the DOM handle to which the nodeHandle belongs."
		},
		"XDOMGetUserData": {
			"prefix": "XDOMGetUserData",
			"body": "XDOMGetUserData($nodeHandle, $userData)",
			"description": "XDOMGetUserData gets the user data associated with the node."
		},
		"XDOMImportNode": {
			"prefix": "XDOMImportNode",
			"body": "XDOMImportNode($xmlHandle, $depth, $importedNodeHandle, $outNodeHandle)",
			"description": "The XDOMImportNode function imports a node from another document into the current document. The returned node has no parent. The source node is not altered or removed from the original document."
		},
		"XDOMInsert": {
			"prefix": "XDOMInsert",
			"body": "XDOMInsert($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag)",
			"description": "XDOMInsert finds the xpathString in the context xmlHandle in the DOM structure, and inserts nodeHandle into the DOM structure as the previous sibling of the found node. If the inserted node type is XDOM.ATTR.NODE, this node is inserted as an attribute."
		},
		"XDOMItem": {
			"prefix": "XDOMItem",
			"body": "XDOMItem($nodeListHandle, $index, $dataHandle, $dataType)",
			"description": "The XDOMItem function returns the index-th item in the list."
		},
		"XDOMLength": {
			"prefix": "XDOMLength",
			"body": "XDOMLength($nodeListHandle, $length)",
			"description": "The XDOMLength function determines the number of nodes in the list. The range of the valid child node index is to 1 to length, inclusive."
		},
		"XDOMLocate": {
			"prefix": "XDOMLocate",
			"body": "XDOMLocate($xmlHandle, $xpathString, $nsMap, $nodeHandle)",
			"description": "XDOMLocate finds a starting point for relative XPath searching in context xmlHandle in the DOM structure. The xpathString should specify only one node; otherwise, this function will return an error."
		},
		"XDOMLocateNode": {
			"prefix": "XDOMLocateNode",
			"body": "XDOMLocateNode($nodeHandle, $direction, $childIndex, $nodeType, $newNodeHandle)",
			"description": "XDOMLocateNode traverses from nodeHandle and gets the next node according to direction and childIndex."
		},
		"XDOMOpen": {
			"prefix": "XDOMOpen",
			"body": "XDOMOpen($xmlDocument, $docLocation, $domHandle)",
			"description": "XDOMOpen reads an XML document and creates a DOM structure. If the DTD is included in the document, UniData validates the document. The XML document can be from a string, or from a file, depending on the docLocation flag."
		},
		"XDOMRemove": {
			"prefix": "XDOMRemove",
			"body": "XDOMRemove($xmlHandle, $xpathString, $nsMap, $attrName, $nodeHandle)",
			"description": "XDOMRemove finds the xpathString in the context xmlHandle in the DOM structure, then removes the found node or its attribute with name attrName."
		},
		"XDOMReplace": {
			"prefix": "XDOMReplace",
			"body": "XDOMReplace($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag)",
			"description": "XDOMReplace finds the xpathString in the context xmlHandle in the DOM structure, and replaces the found node with nodeHandle."
		},
		"XDOMSetNodeValue": {
			"prefix": "XDOMSetNodeValue",
			"body": "XDOMSetNodeValue($nodeHandle, $nodeValue)",
			"description": "XDOMSetNodeValue sets the node value."
		},
		"XDOMSetUserData": {
			"prefix": "XDOMSetUserData",
			"body": "XDOMSetUserData($nodeHandle, $userData)",
			"description": "XDOMSetUserData sets the user data associated with the node."
		},
		"XDOMTransform": {
			"prefix": "XDOMTransform",
			"body": "XDOMTransform($domHandle, $styleSheet, $ssLocation, $outHandle, $outFormat)",
			"description": "XDOMTransform transforms the input DOM structure using the style sheet specified by styleSheetFile to output the DOM structure, file, or string."
		},
		"XDOMValidate": {
			"prefix": "XDOMValidate",
			"body": "XDOMValidate($xmlDocument, $docLocation, $noNsSchema, $noNsSchemaLocation, $NsSchemas)",
			"description": "XDOMValidate validates the DOM document using an external nonamespace schema specified by noNsSchema and, optionally, external namespace schemas specified by NsSchemas."
		},
		"XDOMValidateDom": {
			"prefix": "XDOMValidateDom",
			"body": "XDOMValidateDom($domHandle, $noNsSchema, $noNsSchemaLocation, $NsSchemas)",
			"description": "XDOMValidateDom validates the DOM document using an external no-namespace schema specified by noNsSchema and, optionally, external namespace schemas specified by NsSchemas."
		},
		"XDOMWrite": {
			"prefix": "XDOMWrite",
			"body": "XDOMWrite($domHandle, $xmlDocument, $docLocation, $xmlOptions)",
			"description": "XDOMWrite writes the DOM structure to xmlDocument. xmlDocument can be a string or a file, depending on the value of the docLocation flag."
		},
		"XMAPAppendRec": {
			"prefix": "XMAPAppendRec",
			"body": "XMAPAppendRec($XMAPhandle, $file_name, $record)",
			"description": "The XMAPAppendRec function formats the specified record from the UniData file as a U2XMAP dataset record and appends it to the U2XMAP dataset."
		},
		"XMAPClose": {
			"prefix": "XMAPClose",
			"body": "XMAPClose($XMAPhandle)",
			"description": "The XMAPClose function closes the U2XMAP dataset handle and frees all related structures and memory."
		},
		"XMAPCreate": {
			"prefix": "XMAPCreate",
			"body": "XMAPCreate($u2xmapping_rules, $mapping_flag, $XMAPhandle)",
			"description": "The XMAPCreate function creates an empty XML document for transferring data from the UniData database to XML according the mapping rules you define."
		},
		"XMAPOpen": {
			"prefix": "XMAPOpen",
			"body": "XMAPOpen($xml_document, $doc_flag, $u2xmapping_rules, $u2xmap_flag, $XMAPhandle)",
			"description": "The XMAPOpen function opens an XML document as a U2XMAP data set."
		},
		"XMAPReadNext": {
			"prefix": "XMAPReadNext",
			"body": "XMAPReadNext($XMAPhandle, $file_name, $record)",
			"description": "The XMAPReadNext function retrieves the next record from the U2XMAP dataset and formats it as a record of the UniData file that is being mapped."
		},
		"XMAPToXMLDoc": {
			"prefix": "XMAPToXMLDoc",
			"body": "XMAPToXMLDoc($XMAPhandle, $xmlfile, $doc_flag, $xmlOptions)",
			"description": "The XMAPToXMLDoc function generates an XML document from the data in the U2XMAP dataset using the mapping rules you define. The XML document can be either an XML DOM handle or an XML document. UniData writes the data to a file or a UniBasic variable."
		},
		"XMLError": {
			"prefix": "XMLError",
			"body": "XMLError($errmsg)",
			"description": "Use the XMLError function to get the last error message."
		},
		"XMLExecute": {
			"prefix": "XMLExecute",
			"body": "XMLExecute($cmd, $options, $xmlvar, $xsdvar)",
			"description": "The XMLExecute function enables you to create an XML document using the UniQuery LIST statement or the UniData SQL SELECT statement from a UniBasic program."
		},
		"XMLGetError": {
			"prefix": "XMLGetError",
			"body": "XMLGetError($errorCode, $errorMessage)",
			"description": "XMLGetError gets the error code and error message after the previous XML API failed."
		},
		"XMLGetOptions": {
			"prefix": "XMLGetOptions",
			"body": "XMLGetOptions($outOptions, $delimiterString)",
			"description": "Use this function in UniBasic programs to return the values for encoding and other XML options in effect in the current UniData session."
		},
		"XMLGetOptionValue": {
			"prefix": "XMLGetOptionValue",
			"body": "XMLGetOptionValue($optionName, $outOptionValue)",
			"description": "Use this function in UniBasic programs to return the value of encoding or any other XML option in effect in the current UniData session."
		},
		"XMLSetOptions": {
			"prefix": "XMLSetOptions",
			"body": "XMLSetOptions($options)",
			"description": "Use this function in UniBasic programs to set the encoding parameter and other XML options in the current UniData session. The settings specified in this API override the settings in the system-level and account-level xmlconfig files and in ECL commands during the current session."
		}
	},
	"UniVerse": {
		"acceptConnection": {
			"prefix": "acceptConnection",
			"body": "acceptConnection($svr_socket, $blocking_mode, $timeout, $in_addr, $in_name, $socket_handle)",
			"description": "Use the acceptConnection() function to accept an incoming connection attempt on the server side socket."
		},
		"addAuthenticationRule": {
			"prefix": "addAuthenticationRule",
			"body": "addAuthenticationRule($context, $serverOrClient, $rule, $rulestr)",
			"description": "The addAuthenticationRule() function adds an authentication rule to a security context. The rules are used during SSL negotiation to determine whether the peer is to be trusted."
		},
		"addCertificate": {
			"prefix": "addCertificate",
			"body": "addCertificate($certPath, $usedAs, $format, $algorithm, $context, $p12pass)",
			"description": "The addCertificate() function stores a certificate (or multiple certificates) into a security context to be used as a UniData or UniVerse server or client certificate. Alternatively, it can specify a certificate or a directory which contains the certificates that are either used as CA (Certificate Authority) certificates to verify incoming certificates or act as a Revocation list to check against expired or revoked certificates."
		},
		"addRequestParameter": {
			"prefix": "addRequestParameter",
			"body": "addRequestParameter($request_handle, $parameter_name, $parameter_value, $content_handling)",
			"description": "The addRequestParameter function adds a parameter to the request."
		},
		"amInitialize": {
			"prefix": "amInitialize",
			"body": "amInitialize($hSession, $appName, $policyName, $reasonCode)",
			"description": "The amInitialize function creates and opens an AMI session. The hSession output parameter is a session handle which is valid unless the session is terminated. The function returns a status code indicating success, warning, or failure. You can also use the STATUS() function to obtain this value."
		},
		"amReceiveMsg": {
			"prefix": "amReceiveMsg",
			"body": "amReceiveMsg($hSession, $receiverName, $policyName, $selMsgName, $maxMsgLen, $dataLen, $data, $rcvMsgName, $reasonCode, $recMsgOption)",
			"description": "The amReceiveMsg function receives a message sent by the amSendMsg function."
		},
		"amReceiveRequest": {
			"prefix": "amReceiveRequest",
			"body": "amReceiveRequest($hSession, $receiverName, $policyName, $maxMsgLen, $dataLen, $data, $rcvMsgName, $senderName, $reasonCode, $recReqOption)",
			"description": "The amReceiveRequest function receives a request message."
		},
		"amSendMsg": {
			"prefix": "amSendMsg",
			"body": "amSendMsg($hSession, $senderName, $policyName, $data, $sndMsgName, $reasonCode)",
			"description": "The amSendMsg function sends a datagram (send and forget) message."
		},
		"amSendRequest": {
			"prefix": "amSendRequest",
			"body": "amSendRequest($hSession, $senderName, $policyName, $responseName, $data, $sndMsgName, $reasonCode)",
			"description": "The amSendRequest function sends a request message."
		},
		"amSendResponse": {
			"prefix": "amSendResponse",
			"body": "amSendResponse($hSession, $senderName, $policyName, $rcvMsgName, $data, $sndMsgName, $reasonCode)",
			"description": "The amSendResponse function sends a request message."
		},
		"amTerminate": {
			"prefix": "amTerminate",
			"body": "amTerminate($hSession, $policyName, $reasonCode)",
			"description": "The amTerminate function closes a session."
		},
		"analyzeCertificate": {
			"prefix": "analyzeCertificate",
			"body": "analyzeCertificate($cert, $format, $result, $p12pass)",
			"description": "The analyzeCertificate() function decodes a certificate and puts plain text into the result parameter. The result parameter will then contain such information as the subject name, location, institute, issuer, public key, other extensions, and the issuer\u2019s signature."
		},
		"AuditLog": {
			"prefix": "AuditLog",
			"body": "AuditLog($Originator, $Action, $File, $Record, $Info, $Status, $OldData, $NewData)",
			"description": "To reduce unnecessary or excessive logging, the UniVerse BASICUniBasic AuditLog() function has been added to allow for application-driven audits. For example, instead of enabling system-wide UniVerse BASICUniBasic READ auditing, which could create a huge number of audit log records, you can choose to have your application call this function at a strategic point to have the action recorded in the system audit file."
		},
		"AUTHORIZATION": {
			"prefix": "AUTHORIZATION",
			"body": "AUTHORIZATION $username",
			"description": "Use the AUTHORIZATION statement to specify or change the effective runtime user of a program. After an AUTHORIZATION statement is executed, any SQL security checking acts as if username is running the program."
		},
		"BEGIN TRANSACTION": {
			"prefix": "BEGIN",
			"body": [
				"BEGIN TRANSACTION $ISOLATION_LEVEL $lvl",
				"\t$1",
				"END TRANSACTION"
			],
			"description": "Use the BEGIN TRANSACTION statement to indicate the beginning of a transaction."
		},
		"BITRESET": {
			"prefix": "BITRESET",
			"body": "BITRESET($expr, $bit)",
			"description": "Use the BITRESET function to reset to 0 the bit number of the integer specified by expression. Bits are counted from right to left. The number of the rightmost bit is 0. If the bit is 0, it is left unchanged."
		},
		"BITTEST": {
			"prefix": "BITTEST",
			"body": "BITTEST($expression, $bit)",
			"description": "Use the BITTEST function to test the bit number of the integer specified by expression. The function returns 1 if the bit is set; it returns 0 if it is not. Bits are counted from right to left. The number of the rightmost bit is 0."
		},
		"CENTURY.PIVOT": {
			"prefix": "CENTURY.PIVOT",
			"body": "CENTURY.PIVOT $year",
			"description": "Use the CENTURY.PIVOT function to override the system-wide century pivot year defined in the uvconfig file."
		},
		"CLEARFILE": {
			"prefix": "CLEARFILE",
			"body": "CLEARFILE $variable ON ERROR $err_statements LOCKED $lock_statements",
			"description": "Use the CLEARFILE statement to delete all records in an open dictionary or data file. You cannot use this statement to delete the file itself. Each file to be cleared must be specified in a separate CLEARFILE statement."
		},
		"CLEARPROMPTS": {
			"prefix": "CLEARPROMPTS",
			"body": "CLEARPROMPTS",
			"description": "Use the CLEARPROMPTS statement to clear the value of the inline prompt. Once a value is entered for an in-line prompt, the prompt continues to have that value until a CLEARPROMPTS statement is executed, unless the in-line prompt control option A is specified. CLEARPROMPTS clears all values that have been entered for inline prompts."
		},
		"CLEARSELECT": {
			"prefix": "CLEARSELECT",
			"body": "CLEARSELECT $ListName",
			"description": "Use the CLEARSELECT statement to clear an active select list. This statement is normally used when one or more select lists have been generated but are no longer needed. Clearing select lists prevents remaining select list entries from being used erroneously."
		},
		"closeSocket": {
			"prefix": "closeSocket",
			"body": "closeSocket($socket_handle)",
			"description": "Use the closeSocket() function to close a socket connection."
		},
		"CloseXMLData": {
			"prefix": "CloseXMLData",
			"body": "CloseXMLData($xml_data_handle)",
			"description": "After you finish using an XML data, use CloseXMLData to close the dynamic array variable."
		},
		"COMMIT": {
			"prefix": "COMMIT",
			"body": [
				"COMMIT WORK THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the COMMIT statement to commit all file I\/O changes made during a transaction. The WORK keyword is provided for compatibility with SQL syntax conventions; it is ignored by the compiler."
		},
		"CONVERT Function": {
			"prefix": "CONVERT",
			"body": "CONVERT($search, $replace, $var)",
			"description": "Use the CONVERT function to return a copy of variable with every occurrence of specified characters in variable replaced with other specified characters. Every time a character to be converted appears in variable, it is replaced by the replacement character."
		},
		"CONVERT Statement": {
			"prefix": "CONVERT",
			"body": "CONVERT $fromchars TO $tostring IN $var",
			"description": "Use the CONVERT statement to replace every occurrence of specific characters in a string with other characters. Every time the character to be converted appears in the string, it is replaced by the replacement character."
		},
		"COS": {
			"prefix": "COS",
			"body": "COS($expression)",
			"description": "Use the COS function to return the trigonometric cosine of an angle. expression is an angle expressed as a numeric value in degrees. The COS function is the inverse of the ACOS function."
		},
		"COSH": {
			"prefix": "COSH",
			"body": "COSH($expr)",
			"description": "Use the COSH function to return the hyperbolic cosine of expression. expression must be a numeric value."
		},
		"COUNT": {
			"prefix": "COUNT",
			"body": "COUNT($expression, $delimiter)",
			"description": "Use the COUNT function to return the number of times a substring is repeated in a string value."
		},
		"createCertificate": {
			"prefix": "createCertificate",
			"body": "createCertificate($action, $req, $signKey, $keyPass, $CAcert, $days, $extensions, $certOut, $signAlg)",
			"description": "The createCertificate() function generates a certificate. The certificate can either be a selfsigned certificate as a root CA that can then be used later to sign other certificates, or it can be a CA signed certificate. The generated certificate conforms to X509V3 standard."
		},
		"createCertRequest": {
			"prefix": "createCertRequest",
			"body": "createCertRequest($key, $inFormat, $keyLoc, $algorithm, $digest, $passPhrase, $subjectData, $outFile, $outFormat)",
			"description": "The createCertRequest() function generates a PKCS #10 certificate request from a private key in PKCS #8 form and a set of user specified data. The request can be sent to a CA or used as a parameter to createCertificate() to obtain an X.509 public key certificate."
		},
		"createRequest": {
			"prefix": "createRequest",
			"body": "createRequest($URL, $http_method, $request_handle)",
			"description": "The createRequest function creates an HTTP request and returns a handle to the request."
		},
		"createSecureRequest": {
			"prefix": "createSecureRequest",
			"body": "createSecureRequest($URL, $http_method, $request_handle, $security_context)",
			"description": "The createSecureRequest function behaves exactly the same as the createRequest() function, except for the fourth parameter, a handle to a security context, which is used to associate the security context with the request. If the URL does not start with \u201chttps\u201d then the parameter is ignored. If the URL starts with \u201chttps\u201d but an invalid context handle or no handle is provided, the function will abort and return with an error status."
		},
		"createSecurityContext": {
			"prefix": "createSecurityContext",
			"body": "createSecurityContext($context, $protocol version)",
			"description": "The createSecurityContext() function creates a security context and returns a handle to the context."
		},
		"CRT @": {
			"prefix": "CRT",
			"body": "CRT @($col,$row) $expression",
			"description": "Use the CRT statement to print data on the screen, regardless of whether a PRINTER ON statement has been executed. The syntax for print.list is the same as for a PRINT statement."
		},
		"DELETE Function": {
			"prefix": "DELETE",
			"body": "DELETE($dynarr, $attr, $val, $subval)",
			"description": "Use the DELETE function to erase the data contents of a specified field, value, or subvalue and its corresponding delimiter from a dynamic array. The DELETE function returns the contents of the dynamic array with the specified data removed without changing the actual value of the dynamic array."
		},
		"DIV": {
			"prefix": "DIV",
			"body": "DIV($dividend, $divisor)",
			"description": "Use the DIV function to calculate the value of the quotient after dividend is divided by divisor. The dividend and divisor expressions can evaluate to any numeric value. The only exception is that divisor cannot be 0. If either dividend or divisor evaluates to the null value, null is returned."
		},
		"EOF(ARG.)": {
			"prefix": "EOF(ARG.)",
			"body": "EOF(ARG.)",
			"description": "Use the EOF(ARG.) function to check if the command line argument pointer is past the last command line argument. ARG. is part of the syntax of the EOF(ARG.) function and must be specified. EOF(ARG.) returns 1 (true) if the pointer is past the last command line argument, otherwise it returns 0 (false). The arg# argument of the GET(ARG.) statement and the SEEK(ARG.) statement affect the value of the EOF(ARG.) function."
		},
		"EXECUTE All": {
			"prefix": "EXECUTE",
			"body": "EXECUTE $expression CAPTURING $var PASSLIST $dynarr RTNLIST $varlist SETTING $setvar",
			"description": "Use the EXECUTE statement to execute UniVerse commands from within the BASIC program and then return execution to the statement following the EXECUTE statement."
		},
		"FIELDS": {
			"prefix": "FIELDS",
			"body": "FIELDS($DynArr, $delimiter, $occurrence, $numsubstr)",
			"description": "Use the FIELDS function to return a dynamic array of substrings located between specified delimiters in each element of dynamic.array."
		},
		"FIELDSTORE": {
			"prefix": "FIELDSTORE",
			"body": "FIELDSTORE($string, $delimiter, $i, $n, $repstring)",
			"description": "Use the FIELDSTORE function to modify character strings by inserting, deleting, or replacing fields separated by specified delimiters."
		},
		"FIELDWRITE": {
			"prefix": "FIELDWRITE",
			"body": [
				"FIELDWRITE $expr ON $filevar,$recordkey,$attrexprlist ON ERROR $err LOCKED $lock THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The FIELDWRITE statement allows you to update the specified fields in an existing record and releases locks set by the same process. For those using replication, FIELDWRITE generates field-level replication logs. This statement is similar to WRITEV, but it is not a replacement for WRITEV."
		},
		"FIELDWRITEU": {
			"prefix": "FIELDWRITEU",
			"body": [
				"FIELDWRITEU $expr ON $filevar,$recordkey,$attrexprlist ON ERROR $err LOCKED $lock THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The FIELDWRITE statement allows you to update the specified fields in an existing record and releases locks set by the same process. For those using replication, FIELDWRITE generates field-level replication logs. This statement is similar to WRITEV, but it is not a replacement for WRITEV."
		},
		"FILELOCK": {
			"prefix": "FILELOCK",
			"body": [
				"FILELOCK filevar LOCKED $lock_statements ON ERROR $error_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the FILELOCK statement to acquire a lock on an entire file. This prevents other users from updating the file until the program releases it. A FILELOCK statement that does not specify lock.type is equivalent to obtaining an update record lock on every record of the file."
		},
		"FILEUNLOCK": {
			"prefix": "FILEUNLOCK",
			"body": "FILEUNLOCK $file_variable ON ERROR $statements",
			"description": "Use the FILEUNLOCK statement to release a file lock set by the FILELOCK statement."
		},
		"FIND": {
			"prefix": "FIND",
			"body": [
				"FIND $expression1 IN $Var1 SETTING $Var2 THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the FIND statement to locate an element in dynamic.array. The field, value, and subvalue positions of element are put in the variables fmc, vmc, and smc respectively."
		},
		"FMTS": {
			"prefix": "FMTS",
			"body": "FMTS($DynArr, $format)",
			"description": "Use the FMTS function to format elements of dynamic.array for output. Each element of the array is acted upon independently and is returned as an element in a new dynamic array."
		},
		"FOLD": {
			"prefix": "FOLD",
			"body": "FOLD($str, $width)",
			"description": "Use the FOLD function to divide a string into a number of substrings separated by field marks."
		},
		"FOLDDP": {
			"prefix": "FOLDDP",
			"body": "FOLDDP($str, $len, $mapname)",
			"description": "In NLS mode, use the FOLDDP function to divide a string into a number of substrings separated by field marks. The division is in display positions rather than character lengths."
		},
		"FOOTING": {
			"prefix": "FOOTING",
			"body": "FOOTING $expr",
			"description": "Use the FOOTING statement to specify the text and format of the footing to print at the bottom of each page of output."
		},
		"FOR Loop": {
			"prefix": "FOR",
			"body": [
				"FOR $1 = $2 To $3",
				"$4",
				"NEXT $1"
			],
			"description": "Use the FOR statement to create a FOR\u2026NEXT program loop. A program loop is a series of statements that execute repeatedly until the specified number of repetitions have been performed or until specified conditions are met."
		},
		"FOR Step": {
			"prefix": "FOR",
			"body": [
				"FOR $1 = $2 To $3 STEP $4",
				"$5",
				"NEXT $1"
			],
			"description": "Use the FOR statement to create a FOR\u2026NEXT program loop. A program loop is a series of statements that execute repeatedly until the specified number of repetitions have been performed or until specified conditions are met."
		},
		"FSUB": {
			"prefix": "FSUB",
			"body": "FSUB($expr1, $expr2)",
			"description": "Use the FSUB function to perform floating-point subtraction on two numeric values. number2 is subtracted from number1. If either number evaluates to the null value, null is returned. result equates to number1 minus number2."
		},
		"generateKey": {
			"prefix": "generateKey",
			"body": "generateKey($privKey, $pubKey, $format, $keyLoc, $algorithm, $keyLength, $passPhrase, $paramFile)",
			"description": "The generateKey() function generates a public key cryptography key pair and encrypts the private key. You should then put it into an external key file protected by the provided pass phrase. The protected private key can later be used by UniData and UniVerse SSL sessions (through setPrivateKey()) to secure communication. The public key will not be encrypted."
		},
		"GES": {
			"prefix": "GES",
			"body": "GES($array1, $array2)",
			"description": "Use the GES function to test if elements of one dynamic array are greater than or equal to corresponding elements of another dynamic array."
		},
		"GET": {
			"prefix": "GET",
			"body": [
				"GET $Var SETTING $readcnt FROM device THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use GET statements to read a block of data from an input stream associated with a device, such as a serial line or terminal. The device must be opened with the OPENDEV statement or the OPENSEQ statement. Once the device has been opened, the GET statements read data from the device. The GET statements do not perform any pre- or postprocessing of the data stream, nor do they control local echo characteristics. These aspects of terminal control are handled either by the application or by the device driver. The behavior of certain devices can be managed through the TTYSET\/TTYGET interface."
		},
		"GETX": {
			"prefix": "GETX",
			"body": [
				"GETX $Var SETTING $readcnt FROM device THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use GET statements to read a block of data from an input stream associated with a device, such as a serial line or terminal. The device must be opened with the OPENDEV statement or the OPENSEQ statement. Once the device has been opened, the GET statements read data from the device. The GET statements do not perform any pre- or postprocessing of the data stream, nor do they control local echo characteristics. These aspects of terminal control are handled either by the application or by the device driver. The behavior of certain devices can be managed through the TTYSET\/TTYGET interface."
		},
		"getCipherSuite": {
			"prefix": "getCipherSuite",
			"body": "getCipherSuite($context, $ciphers)",
			"description": "The getCipherSuite() function obtains information about supported cipher suites, their version, usage, strength, and type for the specified security context. The result is put into the dynamic array ciphers, with one line for each cipher suite, separated by a field mark (@FM)."
		},
		"getIpv": {
			"prefix": "getIpv",
			"body": "getIpv($networkexpr)",
			"description": "Use the getIpv function to display the current IPv setting on the whole system or a particular network's connection."
		},
		"GET(ARG.)": {
			"prefix": "GET(ARG.)",
			"body": [
				"GET(ARG. $arg) $var THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the GET(ARG.) statement to retrieve the next command line argument. The command line is delimited by blanks, and the first argument is assumed to be the first word after the program name. When a cataloged program is invoked, the argument list starts with the second word in the command line."
		},
		"getHTTPDefault": {
			"prefix": "getHTTPDefault",
			"body": "getHTTPDefault($opt, $val)",
			"description": "The getHTTPDefault function returns the default values of the HTTP settings. See the section under setHTTPDefault for additional information."
		},
		"GETLIST": {
			"prefix": "GETLIST",
			"body": [
				"GETLIST $listname IN $start, $end TO $variable1 SETTING $variable2 THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the GETLIST statement to activate a saved select list so that a READNEXT statement can use it."
		},
		"GETLOCALE": {
			"prefix": "GETLOCALE",
			"body": "GETLOCALE($cat)",
			"description": "In NLS mode use the GETLOCALE function to return the names of specified categories of the current locale. The GETLOCALE function also returns the details of any saved locale that differs from the current one."
		},
		"GETREM": {
			"prefix": "GETREM",
			"body": "GETREM($dynarr)",
			"description": "Use the GETREM function after the execution of a REMOVE statement, a REMOVE function, or a REVREMOVE statement, to return the numeric value for the character position of the pointer associated with dynamic.array."
		},
		"getSocketErrorMessage": {
			"prefix": "getSocketErrorMessage",
			"body": "getSocketErrorMessage($errCode, $errMsg)",
			"description": "Use the getSocketErrorMessage() function to translate an error code into a text error message. This function works with all socket functions. The return status of those functions can be passed into this function to get the corresponding error message."
		},
		"getSocketInformation": {
			"prefix": "getSocketInformation",
			"body": "getSocketInformation($socket_handle, $self_peer, $socket_info)",
			"description": "Use the getSocketInformation() function to obtain information about a socket connection."
		},
		"getSocketMap": {
			"prefix": "getSocketMap",
			"body": "getSocketMap($aSocket, $mapname)",
			"description": "The getSocketMap() function gets the NLS map associated with the input socket handle with the input socket handle aSocket."
		},
		"getSocketOptions": {
			"prefix": "getSocketOptions",
			"body": "getSocketOptions($socket_handle, $options)",
			"description": "The getSocketOptions() function gets the current value for a socket option associated with a socket of any type."
		},
		"GROUP": {
			"prefix": "GROUP",
			"body": "GROUP($subject, $delimiter, $occurence, $num_to_extract)",
			"description": "Use the GROUP function to return one or more substrings located between specified delimiters in string."
		},
		"GROUPSTORE": {
			"prefix": "GROUPSTORE",
			"body": "GROUPSTORE $newstr IN $str USING $start, $n, $delim",
			"description": "Use the GROUPSTORE statement to modify character strings by inserting, deleting, or replacing fields separated by specified delimiters."
		},
		"HEADING": {
			"prefix": "HEADING",
			"body": "HEADING $expression",
			"description": "Use the HEADING statement to specify the text and format of the heading to print at the top of each page of output."
		},
		"HMAC": {
			"prefix": "HMAC",
			"body": "HMAC($hmacAlg, $hmacKey, $hmacData, $outFormat)",
			"description": "HMAC (keyed-Hash Message Authentication Code) is a specific construction for calculating a message authentication code (MAC) involving a cryptographic hash function in combination with a secret key."
		},
		"HUSH": {
			"prefix": "HUSH",
			"body": "HUSH $expression",
			"description": "Use the HUSH statement to suppress the display of all output normally sent to a terminal during processing. HUSH also suppresses output to a COMO file or TANDEM display."
		},
		"ICHECK": {
			"prefix": "ICHECK",
			"body": "ICHECK($dynarr, $filevar, $key, $col)",
			"description": "Use the ICHECK function to check if data you intend to write to an SQL table violates any SQL integrity constraints. ICHECK verifies that specified data and primary keys satisfy the defined SQL integrity constraints for an SQL table."
		},
		"ICONVS": {
			"prefix": "ICONVS",
			"body": "ICONVS($DynArr, $conversion)",
			"description": "Use the ICONVS function to convert each element of dynamic.array to a specified internal storage format."
		},
		"IF Then": {
			"prefix": "IF",
			"body": [
				"IF $1 THEN",
				"\t$2",
				"END"
			],
			"description": "Use the IF statement to determine program flow based on the evaluation of expression. If the value of expression is true, the THEN clauses are executed. If the value of expression is false, the THEN statements are ignored and the ELSE statements are executed. If expression is the null value, expression evaluates to false. If no ELSE statements are present, program execution continues with the next executable statement."
		},
		"IF Then\/Else": {
			"prefix": "IF",
			"body": [
				"IF $1 THEN",
				"\t$2",
				"END ELSE",
				"\t$3",
				"END"
			],
			"description": "Use the IF statement to determine program flow based on the evaluation of expression. If the value of expression is true, the THEN clauses are executed. If the value of expression is false, the THEN statements are ignored and the ELSE statements are executed. If expression is the null value, expression evaluates to false. If no ELSE statements are present, program execution continues with the next executable statement."
		},
		"IFS": {
			"prefix": "IFS",
			"body": "IFS($dynamic_array, $true_array, $false_array)",
			"description": "Use the IFS function to return a dynamic array whose elements are chosen individually from one of two dynamic arrays based on the contents of a third dynamic array."
		},
		"ILPROMPT": {
			"prefix": "ILPROMPT",
			"body": "ILPROMPT($inLinePrompt)",
			"description": "Use the ILPROMPT function to evaluate a string containing UniVerse in-line prompts."
		},
		"INDEXS": {
			"prefix": "INDEXS",
			"body": "INDEXS($subject, $search, $occurrence)",
			"description": "Use the INDEXS function to return a dynamic array of the starting column positions for a specified occurrence of a substring in each element of dynamic.array."
		},
		"INDICES": {
			"prefix": "INDICES",
			"body": "INDICES($filevar, $indexname)",
			"description": "Use the INDICES function to return information about the secondary key indexes in a file."
		},
		"initSecureServerSocket": {
			"prefix": "initSecureServerSocket",
			"body": "initSecureServerSocket($name_or_IP, $port, $backlog, $svr_socket, $context)",
			"description": "Use the initSecureServerSocket() function to create a secured connection-oriented stream server socket. It does exactly the same as the initServerSocket() function except that the connection will be secure. Once the server socket is opened, any change in the associated security context will not affect the opened socket."
		},
		"initServerSocket": {
			"prefix": "initServerSocket",
			"body": "initServerSocket($name_or_IP, $port, $backlog, $svr_socket)",
			"description": "Use the initServerSocket() function to create a connection-oriented (stream) socket. Associate this socket with an address (name_or_IP) and port number (port), and specify the maximum length the queue of pending connections may grow to."
		},
		"INMAT": {
			"prefix": "INMAT",
			"body": "INMAT($array)",
			"description": "Use the INMAT function to return the number of array elements that have been loaded after the execution of MATREAD statements, MATREADL statement, MATREADU statement, or MATPARSE statement, or to return the modulo of a file after the execution of an OPEN statement. You can also use the INMAT function after a DIMENSION statement to determine whether the DIM statement failed due to lack of available memory. If a preceding DIM statement fails, INMAT returns a value of 1."
		},
		"INPUT": {
			"prefix": "INPUT",
			"body": "INPUT $var",
			"description": "Use the INPUT statement to halt program execution and prompt the user to enter a response. Data entered at the terminal or supplied by a DATA statement in response to an INPUT statement is assigned to variable. Input supplied by a DATA statement is echoed to the terminal. If the response is a RETURN with no preceding data, an empty string is assigned to variable."
		},
		"INPUT @": {
			"prefix": "INPUT",
			"body": "INPUT @($col, $row) $var",
			"description": "Use the INPUT statement to halt program execution and prompt the user to enter a response. Data entered at the terminal or supplied by a DATA statement in response to an INPUT statement is assigned to variable. Input supplied by a DATA statement is echoed to the terminal. If the response is a RETURN with no preceding data, an empty string is assigned to variable."
		},
		"INPUTCLEAR": {
			"prefix": "INPUTCLEAR",
			"body": "INPUTCLEAR",
			"description": "Use the INPUTCLEAR statement to clear the type-ahead buffer. You can use this statement before input prompts so input is not affected by unwanted characters."
		},
		"INPUTDISP": {
			"prefix": "INPUTDISP",
			"body": "INPUTDISP @($col, $row) $var",
			"description": "Use the INPUTDISP statement with an @ expression to position the cursor at a specified location and define a format for the variable to print. The current contents of variable are displayed as the value in the defined field. Calculations are based on display length rather than character length."
		},
		"INPUTDP": {
			"prefix": "INPUTDP",
			"body": [
				"INPUTDP $var THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "In NLS mode, use the INPUTDP statement to let the user enter data. The INPUTDP statement is similar to the INPUT statement, INPUTIF statement, and INPUTDISP statement, but it calculates display positions rather than character lengths."
		},
		"INPUTERR": {
			"prefix": "INPUTERR",
			"body": "INPUTERR $errMsg",
			"description": "Use the INPUTERR statement to print a formatted error message on the bottom line of the terminal. error.message is an expression that evaluates to the error message text. The message is cleared by the next INPUT statement or is overwritten by the next INPUTERR statement or PRINTERR statement. INPUTERR clears the type-ahead buffer."
		},
		"INPUTIF": {
			"prefix": "INPUTIF",
			"body": "INPUTIF $1",
			"description": "Use the INPUTIF statement to assign the contents of the type-ahead buffer to a variable."
		},
		"INPUTNULL": {
			"prefix": "INPUTNULL",
			"body": "INPUTNULL $char",
			"description": "Use the INPUTNULL statement to define a character to be recognized as an empty string when it is input in response to an INPUT statement. If the only input to the INPUT statement is character, that character is recognized as an empty string. character replaces the default value of the INPUT variable with an empty string. If character evaluates to the null value, the INPUTNULL statement fails and the program terminates with a run-time error message."
		},
		"INPUTTRAP": {
			"prefix": "INPUTTRAP",
			"body": "INPUTTRAP $chars GOSUB $label1",
			"description": "Use the INPUTTRAP statement to branch to a program label or subroutine when a trap character is input. Execution is passed to the statement label which corresponds to the trap number of the trap character. If the trap number is larger than the number of labels, execution is passed to the statement specified by the last label in the list."
		},
		"INS": {
			"prefix": "INS",
			"body": "INS $expression BEFORE $array<$attr, $value, $subvalue>",
			"description": "Use the INS statement to insert a new field, value, or subvalue into the specified dynamic.array."
		},
		"INSERT": {
			"prefix": "INSERT",
			"body": "INSERT($DynArr, $attr, $value, $subvalue; $expression)",
			"description": "Use the INSERT function to return a dynamic array that has a new field, value, or subvalue inserted into the specified dynamic array."
		},
		"ISNULL": {
			"prefix": "ISNULL",
			"body": "ISNULL($var)",
			"description": "Use the ISNULL function to test whether a variable is the null value. If variable is the null value, 1 (true) is returned, otherwise 0 (false) is returned. This is the only way to test for the null value since the null value is not equal to any value, including itself."
		},
		"ISNULLS": {
			"prefix": "ISNULLS",
			"body": "ISNULLS($dynarr)",
			"description": "Use the ISNULLS function to test whether any element of dynamic.array is the null value. A dynamic array is returned, each of whose elements is either 1 (true) or 0 (false). If an element in dynamic.array is the null value, 1 is returned, otherwise 0 is returned. This is the only way to test for the null value since the null value is not equal to any value, including itself."
		},
		"ITYPE": {
			"prefix": "ITYPE",
			"body": "ITYPE($item)",
			"description": "The ITYPE function leverages the object code stored within a compiled i.type item to return a result."
		},
		"KEYEDIT": {
			"prefix": "KEYEDIT",
			"body": "KEYEDIT($action, $key)",
			"description": "Use the KEYEDIT statement to assign specific keyboard keys to the editing functions of the INPUT @ statement, and to the !EDIT.INPUT and !GET.KEY subroutines."
		},
		"KEYEXIT": {
			"prefix": "KEYEXIT",
			"body": "KEYEXIT($action, $key)",
			"description": "Use the KEYEXIT statement to specify exit traps for the keys assigned specific functions by the KEYEDIT statement. When an exit trap key is typed, the variable being edited with the INPUT @ statement or the !EDIT.INPUT subroutine remains in its last edited state. Use the KEYTRAP statement to restore the variable to its initial state."
		},
		"KEYIN": {
			"prefix": "KEYIN",
			"body": "KEYIN()",
			"description": "Use the KEYIN function to read a single character from the input buffer and return it. All UniVerse special character handling (such as case inversion, erase, kill, and so on) is disabled. UNIX special character handling (processing of interrupts, XON\/XOFF, conversion of CR to LF, and so on) still takes place. Calculations are based on display length rather than character length. No arguments are required with the KEYIN function; however, parentheses are required."
		},
		"KEYTRAP": {
			"prefix": "KEYTRAP",
			"body": "KEYTRAP($action, $key)",
			"description": "Use the KEYTRAP statement to specify traps for the keys assigned specific functions by the KEYEDIT statement. When a trap key is typed, the variable being edited with the INPUT @ statement or the !EDIT.INPUT subroutine is restored to its initial state. Use the KEYEXIT statement to leave the variable in its last edited state."
		},
		"LEFT": {
			"prefix": "LEFT",
			"body": "LEFT($str, $length)",
			"description": "Use the LEFT function to extract a substring comprising the first n characters of a string, without specifying the starting character position."
		},
		"LENDP": {
			"prefix": "LENDP",
			"body": "LENDP($expression, $mapname)",
			"description": "In NLS mode, use the LENDP function to return the number of display positions occupied by string when using the specified map. Calculations are based on display length rather than character length."
		},
		"LENS": {
			"prefix": "LENS",
			"body": "LENS($dynamic_array)",
			"description": "Use the LENS function to return a dynamic array of the number of display positions in each element of dynamic.array. Calculations are based on character length rather than display length."
		},
		"LENSDP": {
			"prefix": "LENSDP",
			"body": "LENSDP($dynarr, $mapname)",
			"description": "In NLS mode, use the LENSDP function to return a dynamic array of the number of display positions occupied by each element of dynamic.array. Calculations are based on display length rather than character length."
		},
		"LES": {
			"prefix": "LES",
			"body": "LES($array1, $array2)",
			"description": "Use the LES function to test if elements of one dynamic array are less than or equal to the elements of another dynamic array."
		},
		"LET": {
			"prefix": "LET",
			"body": "LET $var = $expr",
			"description": "Use the LET statement to assign the value of expression to variable."
		},
		"LN": {
			"prefix": "LN",
			"body": "LN($expression)",
			"description": "Use the LN function to calculate the natural logarithm of the value of an expression, using base \"e\". The value of \"e\" is approximately 2.71828. expression must evaluate to a numeric value greater than 0. If expression is 0 or negative, 0 is returned and a warning is printed. If expression evaluates to the null value, null is returned."
		},
		"loadSecurityContext": {
			"prefix": "loadSecurityContext",
			"body": "loadSecurityContext($context, $name, $passPhrase)",
			"description": "The loadSecurityContext() function loads a saved security context record into the current session. The name and passPhrase parameters are needed to retrieve and decrypt the saved context. An internal data structure is created and its handle is returned in the context parameter."
		},
		"LOCALEINFO": {
			"prefix": "LOCALEINFO",
			"body": "LOCALEINFO($category)",
			"description": "In NLS mode, use the LOCALEINFO function to retrieve the settings of the current locale."
		},
		"LOCATE Function": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE($search, $subject; $returnVar) THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the LOCATE statement to search dynamic.array for a field, value, or subvalue."
		},
		"LOCATE Statement": {
			"prefix": "LOCATE",
			"body": [
				"LOCATE $search IN $subject SETTING $returnVar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the LOCATE statement to search dynamic.array for a field, value, or subvalue."
		},
		"LOCK": {
			"prefix": "LOCK",
			"body": [
				"LOCK $expression THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the LOCK statement to protect specified user-defined resources or events against unauthorized use or simultaneous data file access by different users."
		},
		"LOOP While": {
			"prefix": "LOOP",
			"body": [
				"LOOP",
				"\t$statement1",
				"WHILE $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "Use the LOOP statement to start a LOOP\u2026REPEAT program loop. A program loop is a series of statements that executes for a specified number of repetitions or until specified conditions are met."
		},
		"LOOP Until": {
			"prefix": "LOOP",
			"body": [
				"LOOP",
				"\t$statement1",
				"UNTIL $expression DO",
				"\t$statement2",
				"REPEAT"
			],
			"description": "Use the LOOP statement to start a LOOP\u2026REPEAT program loop. A program loop is a series of statements that executes for a specified number of repetitions or until specified conditions are met."
		},
		"LTS": {
			"prefix": "LTS",
			"body": "LTS($arr1, $arr2)",
			"description": "Use the LTS function to test if elements of one dynamic array are less than elements of another dynamic array."
		},
		"MATBUILD": {
			"prefix": "MATBUILD",
			"body": "MATBUILD $variable FROM $array, $startexpr, $endexpr USING $delim",
			"description": "Use the MATBUILD statement to build a dynamic array from a dimensioned array."
		},
		"MATCHFIELD": {
			"prefix": "MATCHFIELD",
			"body": "MATCHFIELD($string, $pattern, $element)",
			"description": "Use the MATCHFIELD function to check a string against a match pattern."
		},
		"MATPARSE": {
			"prefix": "MATPARSE",
			"body": "MATPARSE $arr FROM $str",
			"description": "Use the MATPARSE statement to separate the fields of dynamic.array into consecutive elements of array."
		},
		"MATREAD": {
			"prefix": "MATREAD",
			"body": [
				"MATREAD $mat FROM $filevar, $recordkey THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the MATREAD statement to assign the contents of the fields of a record from a UniVerse file to consecutive elements of array. The first field of the record becomes the first element of array, the second field of the record becomes the second element of array, and so on. The array must be named and dimensioned in a DIMENSION statement or COMMON statement before it is used in this statement."
		},
		"MATREADL": {
			"prefix": "MATREADL",
			"body": [
				"MATREADL $mat FROM $filevar, $recordkey THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the MATREADL statement to set a shared record lock and perform the MATREAD statement."
		},
		"MATREADU": {
			"prefix": "MATREADU",
			"body": [
				"MATREADU $mat FROM $filevar, $recordkey THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the MATREADU statement to set an update record lock and perform the MATREAD statement."
		},
		"MATWRITE": {
			"prefix": "MATWRITE",
			"body": "MATWRITE $mat TO $filevar, $recordkey",
			"description": "Use the MATWRITE statement to write data from the elements of a dimensioned array to a record in a UniVerse file. The elements of array replace any data stored in the record. MATWRITE strips any trailing empty fields from the record."
		},
		"MATWRITEU": {
			"prefix": "MATWRITEU",
			"body": "MATWRITEU $mat TO $filevar, $recordkey",
			"description": "Use the MATWRITEU statement to maintain an update record lock and perform the MATWRITE statement."
		},
		"MAXIMUM": {
			"prefix": "MAXIMUM",
			"body": "MAXIMUM($DynArr)",
			"description": "Use the MAXIMUM function to return the element with the highest numeric value in dynamic.array. Nonnumeric values, except the null value, are treated as 0. If dynamic.array evaluates to the null value, null is returned. Any element that is the null value is ignored, unless all elements of dynamic.array are null, in which case null is returned."
		},
		"MINIMUM": {
			"prefix": "MINIMUM",
			"body": "MINIMUM($DynArr)",
			"description": "Use the MINIMUM function to return the element with the lowest numeric value in dynamic.array. Nonnumeric values and empty strings, except the SQL null value, are treated as 0. If dynamic.array evaluates to the null value, null is returned. Any element that is the null value is ignored, unless all elements of dynamic.array are null, in which case null is returned."
		},
		"MOD": {
			"prefix": "MOD",
			"body": "MOD($dividend, $divisor)",
			"description": "Use the MOD function to calculate the value of the remainder after integer division is performed on the dividend expression by the divisor expression."
		},
		"MODS": {
			"prefix": "MODS",
			"body": "MODS($array1, $array2)",
			"description": "Use the MODS function to create a dynamic array of the remainder after the integer division of corresponding elements of two dynamic arrays."
		},
		"MQCLOSE": {
			"prefix": "MQCLOSE",
			"body": "MQCLOSE($hConn, $hObj, $options)",
			"description": "Use the MQCLOSE() function to close access to a queue or other object. When you close the queue, the queue and all uncommitted messages on the queue are deleted."
		},
		"MQCONN": {
			"prefix": "MQCONN",
			"body": "MQCONN($qManager, $hConn)",
			"description": "The MQCONN() function connects an application to a WebSphere MQ queue manager."
		},
		"MQDISC": {
			"prefix": "MQDISC",
			"body": "MQDISC($hConn)",
			"description": "The MQDISC function terminates connections to the queue manager that were create using the MQCONN function. The input for this function is the hConn connection handle returned by the MQCONN function."
		},
		"MULS": {
			"prefix": "MULS",
			"body": "MULS($array1, $array2)",
			"description": "Use the MULS function to create a dynamic array of the element-by-element multiplication of two dynamic arrays."
		},
		"NAP": {
			"prefix": "NAP",
			"body": "NAP $milliseconds",
			"description": "Use the NAP statement to suspend the execution of a BASIC program, pausing for a specified number of milliseconds."
		},
		"NEG": {
			"prefix": "NEG",
			"body": "NEG($num)",
			"description": "Use the NEG function to return the arithmetic inverse of the value of the argument. number is an expression evaluating to a number."
		},
		"NEGS": {
			"prefix": "NEGS",
			"body": "NEGS($DynArr)",
			"description": "Use the NEGS function to return the negative values of all the elements in a dynamic array. If the value of an element is negative, the returned value is positive. If dynamic.array evaluates to the null value, null is returned. If any element is null, null is returned for that element."
		},
		"NES": {
			"prefix": "NES",
			"body": "NES($arr1, $arr2)",
			"description": "Use the NES function to test if elements of one dynamic array are equal to the elements of another dynamic array."
		},
		"NOBUF": {
			"prefix": "NOBUF",
			"body": [
				"NOBUF $file_variable THEN ",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the NOBUF statement to turn off buffering for a file previously opened for sequential processing. Normally UniVerse uses buffering for sequential input and output operations. The NOBUF statement turns off this buffering and causes all writes to the file to be performed immediately. It eliminates the need for FLUSH statement operations but also eliminates the benefits of buffering. The NOBUF statement must be executed after a successful OPENSEQ statement or CREATE statement and before any input or output operation is performed on the record."
		},
		"NOTS": {
			"prefix": "NOTS",
			"body": "NOTS($DynArr)",
			"description": "Use the NOTS function to return a dynamic array of the logical complements of each element of dynamic.array. If the value of the element is true, the NOTS function returns a value of false (0) in the corresponding element of the returned array. If the value of the element is false, the NOTS function returns a value of true (1) in the corresponding element of the returned array."
		},
		"NULL": {
			"prefix": "NULL",
			"body": "NULL",
			"description": "Use the NULL statement when a statement is required but no operation is to be performed. For example, you can use it with the ELSE clause if you do not want any operation performed when the ELSE clause is executed."
		},
		"NUM": {
			"prefix": "NUM",
			"body": "NUM($expr)",
			"description": "Use the NUM function to determine whether expression is a numeric or nonnumeric string. If expression is a number, a numeric string, or an empty string, it evaluates to true and a value of 1 is returned. If expression is a nonnumeric string, it evaluates to false and a value of 0 is returned."
		},
		"NUMS": {
			"prefix": "NUMS",
			"body": "NUMS($DynArr)",
			"description": "Use the NUMS function to determine whether the elements of a dynamic array are numeric or nonnumeric strings. If an element is numeric, a numeric string, or an empty string, it evaluates to true, and a value of 1 is returned to the corresponding element in a new dynamic array. If the element is a nonnumeric string, it evaluates to false, and a value of 0 is returned."
		},
		"OCONVS": {
			"prefix": "OCONVS",
			"body": "OCONVS($DynArr, $conversion)",
			"description": "Use the OCONVS function to convert the elements of dynamic.array to a specified format for external output."
		},
		"ON": {
			"prefix": "ON",
			"body": "ON $expr GOSUB $label",
			"description": "Use the ON statement to transfer program control to one of the internal subroutines named in the GOSUB clause or to one of the statements named in the GOTO clause."
		},
		"OPENCHECK": {
			"prefix": "OPENCHECK",
			"body": [
				"OPENCHECK $filename TO $filevar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the OPENCHECK statement to open an SQL table for use by BASIC programs, enforcing SQL integrity checking. All file references in a BASIC program must be preceded by either an OPENCHECK statement or an OPEN statement for that file."
		},
		"OPENDEV": {
			"prefix": "OPENDEV",
			"body": [
				"OPENDEV $Device TO $filevar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the OPENDEV statement to open a device for sequential processing. OPENDEV also sets a record lock on the opened device or file."
		},
		"OPENPATH": {
			"prefix": "OPENPATH",
			"body": [
				"OPENPATH $pathname TO $filevar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "The OPENPATH statement is similar to the OPEN statement, except that the pathname of the file is specified. This file is opened without reference to the VOC file. The file must be a hashed UniVerse file or a directory (UniVerse types 1 and 19)."
		},
		"OPENSEQ": {
			"prefix": "OPENSEQ",
			"body": [
				"OPENSEQ $filename, $recordid TO $filevar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the OPENSEQ statement to open a file for sequential processing. All sequential file references in a BASIC program must be preceded by an OPENSEQ or OPENDEV statement for that file. Although you can open several files for sequential processing at the same point in the program, you must issue a separate OPENSEQ statement for each."
		},
		"openSecureSocket": {
			"prefix": "openSecureSocket",
			"body": "openSecureSocket($name_or_IP, $port, $mode, $timeout, $socket_handle, $context)",
			"description": "Use the openSecureSocket() function to open a secure socket connection in a specified mode and return the status."
		},
		"openSocket": {
			"prefix": "openSocket",
			"body": "openSocket($name_or_IP, $port, $mode, $timeout, $socket_handle)",
			"description": "Use the openSocket() function to open a socket connection in a specified mode and return the status."
		},
		"OpenXMLData": {
			"prefix": "OpenXMLData",
			"body": "OpenXMLData($xml_handle, $xml_data_extraction_rule, $xml_data_handle)",
			"description": "After you prepare the XML document, open it using the OpenXMLData function."
		},
		"ORS": {
			"prefix": "ORS",
			"body": "ORS($arr1, $arr2)",
			"description": "Use the ORS function to create a dynamic array of the logical OR of corresponding elements of two dynamic arrays."
		},
		"PAGE": {
			"prefix": "PAGE",
			"body": "PAGE $1",
			"description": "Use the PAGE statement to print headings, footings, and page advances at the appropriate places on the specified output device."
		},
		"PERFORM": {
			"prefix": "PERFORM",
			"body": "PERFORM $expression",
			"description": "Use the PERFORM statement to execute a UniVerse sentence, paragraph, menu, or command from within the BASIC program, then return execution to the statement following the PERFORM statement. The commands are executed in the same environment as the BASIC program that called them; that is, unnamed common variables, @variables, and in-line prompts retain their values, and select lists and the DATA stack remain active. If these values change, the new values are passed back to the calling program."
		},
		"PRECISION": {
			"prefix": "PRECISION",
			"body": "PRECISION $integer",
			"description": "Use the PRECISION statement to control the maximum number of decimal places that are output when the system converts a numeric value from internal binary format to an ASCII character string value."
		},
		"PrepareXML": {
			"prefix": "PrepareXML",
			"body": "PrepareXML($xml_file, $xml_handle)",
			"description": "The PrepareXML function allocates memory for the XML document, opens the document, determines the file structure of the document, and returns the file structure."
		},
		"PRINTER": {
			"prefix": "PRINTER",
			"body": "PRINTER $ON_OFF_RESET",
			"description": "Use the PRINTER statement to direct output either to the screen or to a printer. By default, all output is sent to the screen unless a PRINTER ON is executed or the P option to the RUN command is used. See the SETPTR command for more details about redirecting output."
		},
		"PRINTERR": {
			"prefix": "PRINTERR",
			"body": "PRINTERR $errMsg",
			"description": "Use the PRINTERR statement to print a formatted error message on the bottom line of the terminal. The message is cleared by the next INPUT @ statement or is overwritten by the next PRINTERR or INPUTERR statement. PRINTERR clears the type-ahead buffer."
		},
		"PROCREAD": {
			"prefix": "PROCREAD",
			"body": [
				"PROCREAD $variable THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the PROCREAD statement to assign the contents of the primary input buffer to a variable. Your BASIC program must be called by a proc. If your program was not called from a proc, the ELSE statements are executed; otherwise the THEN statements are executed."
		},
		"PROCWRITE": {
			"prefix": "PROCWRITE",
			"body": "PROCWRITE $str",
			"description": "Use the PROCWRITE statement to write string to the primary input buffer. Your program must be called by a proc."
		},
		"PROMPT": {
			"prefix": "PROMPT",
			"body": "PROMPT $char",
			"description": "Use the PROMPT statement to specify the character to be displayed on the screen when user input is required. If no PROMPT statement is issued, the default prompt character is the question mark (? )."
		},
		"protocolLogging": {
			"prefix": "protocolLogging",
			"body": "protocolLogging($log_file, $log_action, $log_level)",
			"description": "The protocolLogging function starts or stops logging."
		},
		"PWR": {
			"prefix": "PWR",
			"body": "PWR($expr, $power)",
			"description": "Use the PWR function to return the value of expression raised to the power specified by power."
		},
		"PyCall": {
			"prefix": "PyCall",
			"body": "PyCall(PyObj, $args)",
			"description": "The PyCall function calls a Python callable object."
		},
		"PyCallFunction": {
			"prefix": "PyCallFunction",
			"body": "PyCallFunction($moduleName, $funcName, $args)",
			"description": "The PyCallFunction function calls a Python function on a Python module."
		},
		"PyCallMethod": {
			"prefix": "PyCallMethod",
			"body": "PyCallMethod($pyObj, $methName, $args)",
			"description": "The PyCallMethod function calls a method on a Python object."
		},
		"PyGetAttr": {
			"prefix": "PyGetAttr",
			"body": "PyGetAttr($pyobj, $attrName)",
			"description": "The PyGetAttr function gets the value of an attribute of a Python object."
		},
		"PyImport": {
			"prefix": "PyImport",
			"body": "PyImport($moduleName)",
			"description": "The PyImport function imports a Python module."
		},
		"PySetAttr": {
			"prefix": "PySetAttr",
			"body": "PySetAttr($pyobj, $attrName, $val)",
			"description": "The PySetAttr function sets the value of an attribute of a Python object."
		},
		"QUOTE": {
			"prefix": "QUOTE",
			"body": "QUOTE($expression)",
			"description": "Use the QUOTE function to enclose an expression in double quotation marks. If expression evaluates to the null value, null is returned (without quotation marks)."
		},
		"RANDOMIZE": {
			"prefix": "RANDOMIZE",
			"body": "RANDOMIZE $expression",
			"description": "Use the RANDOMIZE statement with an expression to make the RND function generate the same sequence of random numbers each time the program is run. expression must be a positive integer or zero. If no expression is supplied, or if expression evaluates to the null value, the internal time of day is used (the null value is ignored). In these cases the sequence is different each time the program is run."
		},
		"READBLK": {
			"prefix": "READBLK",
			"body": [
				"READBLK $var $ENCODING FROM $filevariable, $blocksize THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the READBLK statement to read a block of data of a specified length from a file opened for sequential processing and assign it to a variable. The READBLK statement reads a block of data beginning at the current position in the file and continuing for blocksize bytes and assigns it to variable. The current position is reset to just beyond the last byte read."
		},
		"READL": {
			"prefix": "READL",
			"body": [
				"READL $var FROM $filevar,$recordkey THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the READL statement to acquire a shared record lock and perform the READ statement."
		},
		"READNEXT": {
			"prefix": "READNEXT",
			"body": "READNEXT $var FROM $list",
			"description": "Use the READNEXT statement to assign the next record ID from an active select list to dynamic.array."
		},
		"READSEQ": {
			"prefix": "READSEQ",
			"body": [
				"READSEQ $var FROM $filevar ON ERROR $err_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the READSEQ statement to read a line of data from a file opened for sequential processing. Sequential processing lets you process data one line at a time. UniVerse keeps a pointer at the current position in the file. The $OPTIONS statement sets this pointer to the first byte of the file, and it is advanced by READSEQ, READBLK statement, WRITESEQ statement, and WRITEBLK statement."
		},
		"readSocket": {
			"prefix": "readSocket",
			"body": "readSocket($socket_handle, $socket_data, $max_read_size, $time_out, $mode, $actual_read_size)",
			"description": "Use the readSocket() function to read data in the socket buffer up to max_read_size characters."
		},
		"READT": {
			"prefix": "READT",
			"body": [
				"READT $variable FROM $expression THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the READT statement to read the next tape record from a magnetic tape unit and assign its contents to a variable."
		},
		"READVL": {
			"prefix": "READVL",
			"body": [
				"READVL $var FROM $filevar,$recordkey,$attr THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the READV statement to read the contents of a specified field of a record in a UniVerse file."
		},
		"READVU": {
			"prefix": "READVU",
			"body": [
				"READVU $var FROM $filevar,$recordkey,$attr LOCKED $lock_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the READV statement to read the contents of a specified field of a record in a UniVerse file."
		},
		"ReadXMLData": {
			"prefix": "ReadXMLData",
			"body": "ReadXMLData($xml_data_handle, $rec)",
			"description": "After you open an XML document, read the document using the ReadXMLData function. UniVerse BASIC returns the XML data as a dynamic array."
		},
		"REAL": {
			"prefix": "REAL",
			"body": "REAL($num)",
			"description": "Use the REAL function to convert number into a floating-point number without loss of accuracy. If number evaluates to the null value, null is returned."
		},
		"RECORDLOCKL": {
			"prefix": "RECORDLOCKL",
			"body": "RECORDLOCKL $filevar, $recordid",
			"description": "Use RECORDLOCK statements to acquire a record lock on a record without reading the record."
		},
		"RECORDLOCKU": {
			"prefix": "RECORDLOCKU",
			"body": "RECORDLOCKU $filevar, $recordid",
			"description": "Use RECORDLOCK statements to acquire a record lock on a record without reading the record."
		},
		"RECORDLOCKED": {
			"prefix": "RECORDLOCKED",
			"body": "RECORDLOCKED($filevar, $recordkey)",
			"description": "Use the RECORDLOCKED function to return the status of a record lock."
		},
		"ReleaseXML": {
			"prefix": "ReleaseXML",
			"body": "ReleaseXML($XMLhandle)",
			"description": "Release the XML dynamic array after closing it using the ReleaseXML function. ReleaseXML destroys the internal DOM tree and releases the associated memory."
		},
		"REM Function": {
			"prefix": "REM",
			"body": "REM($dividend, $divisor)",
			"description": "Use the REM function to calculate the remainder after integer division is performed on the dividend expression by the divisor expression."
		},
		"REM Statement": {
			"prefix": "REM",
			"body": "REM $comment",
			"description": "Use the REM statement to insert a comment in a BASIC program. Comments explain or document various parts of a program. They are part of the source code only and are nonexecutable. They do not affect the size of the object code."
		},
		"REMOVE Function": {
			"prefix": "REMOVE",
			"body": "REMOVE($dynarr, $var)",
			"description": "Use the REMOVE function to successively extract and return dynamic array elements that are separated by system delimiters, and to indicate which system delimiter was found. When a system delimiter is encountered, the value of the extracted element is returned. The REMOVE function is more efficient than the EXTRACT function for extracting successive fields, values, and so on, for multivalue list processing."
		},
		"REMOVE Statement": {
			"prefix": "REMOVE",
			"body": "REMOVE $variable FROM $array SETTING $setvar",
			"description": "Use the REMOVE statement to successively extract dynamic array elements that are separated by system delimiters. When a system delimiter is encountered, the extracted element is assigned to element. The REMOVE statement is more efficient than the EXTRACT function for extracting successive fields, values, and so on, for multivalue list processing."
		},
		"REPLACE": {
			"prefix": "REPLACE",
			"body": "REPLACE($var, $attr, $value, $subvalue; $replace)",
			"description": "Use the REPLACE function to return a copy of a dynamic array with the specified field, value, or subvalue replaced with new data."
		},
		"RETURN (value)": {
			"prefix": "RETURN (value)",
			"body": "RETURN ($value)",
			"description": "Use the RETURN (value) statement to return a value from a user-written function."
		},
		"REUSE": {
			"prefix": "REUSE",
			"body": "REUSE($dynarr)",
			"description": "Use the REUSE function to specify that the value of the last field, value, or subvalue be reused in a dynamic array operation."
		},
		"REVREMOVE": {
			"prefix": "REVREMOVE",
			"body": "REVREMOVE $element FROM $dynarr SETTING $var",
			"description": "Use the REVREMOVE statement to successively extract dynamic array elements that are separated by system delimiters. The elements are extracted from right to left, in the opposite order from those extracted by the REMOVE statement. When a system delimiter is encountered, the extracted element is assigned to element."
		},
		"REWIND": {
			"prefix": "REWIND",
			"body": [
				"REWIND $UNIT THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the REWIND statement to rewind a magnetic tape to the beginning-of-tape position."
		},
		"RIGHT": {
			"prefix": "RIGHT",
			"body": "RIGHT($str, $length)",
			"description": "Use the RIGHT function to extract a substring comprising the last n characters of a string."
		},
		"RND": {
			"prefix": "RND",
			"body": "RND($expr)",
			"description": "Use the RND function to generate any positive or negative random integer or 0."
		},
		"ROLLBACK": {
			"prefix": "ROLLBACK",
			"body": [
				"ROLLBACK $WORK THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the ROLLBACK statement to cancel all file I\/O changes made during a transaction. The WORK keyword provides compatibility with SQL syntax conventions; it is ignored by the compiler."
		},
		"ROUND": {
			"prefix": "ROUND",
			"body": "ROUND($num, $places)",
			"description": "Use the ROUND function to round a numeric value to the specified number of decimal places."
		},
		"RPC.CALL": {
			"prefix": "RPC.CALL",
			"body": "RPC.CALL ($connID, $procedure, $numargs, MAT $arglist, $numvalues, MAT $return.list)",
			"description": "Use the RPC.CALL function to make requests of a connected server. The request is packaged and sent to the server using the C client RPC library. RPC.CALL returns the results of processing the remote request: 1 for success, 0 for failure."
		},
		"RPC.CONNECT": {
			"prefix": "RPC.CONNECT",
			"body": "RPC.CONNECT($host, $server)",
			"description": "Use the RPC.CONNECT function to establish a connection to a server process. Once the host and server are identified, the local UVNet daemon tries to connect to the remote server. If the attempt succeeds, RPC.CONNECT returns a connection ID. If it fails, RPC.CONNECT returns 0. The connection ID is a nonzero integer used to refer to the server in subsequent calls to RPC.CALL function and RPC.DISCONNECT function."
		},
		"RPC.DISCONNECT": {
			"prefix": "RPC.DISCONNECT",
			"body": "RPC.DISCONNECT($connID)",
			"description": "Use the RPC.DISCONNECT function to end an RPC session."
		},
		"RQM": {
			"prefix": "RQM",
			"body": "RQM $seconds",
			"description": "RQM is a synonym for the SLEEP statement."
		},
		"SADD": {
			"prefix": "SADD",
			"body": "SADD($1, $2)",
			"description": "Use the SADD function to add two string numbers and return the result as a string number. You can use this function in any expression where a string or string number is valid, but not necessarily where a standard number is valid, because string numbers can exceed the range of numbers that standard arithmetic operators can handle."
		},
		"saveSecurityContext": {
			"prefix": "saveSecurityContext",
			"body": "saveSecurityContext($context, $name, $passPhrase)",
			"description": "The saveSecurityContext() function encrypts and saves a security context to a system security file. The file is maintained on a per account basis for UniData and UniVerse. The name is used as the record ID to access the saved security information. Since the information is encrypted, you should not attempt to directly manipulate it."
		},
		"SDIV": {
			"prefix": "SDIV",
			"body": "SDIV($1, $2, $precision)",
			"description": "Use the SDIV function to divide string.number.1 by string.number.2 and return the result as a string number. You can use this function in any expression where a string or string number is valid, but not necessarily where a standard number is valid, because string numbers can exceed the range of numbers which standard arithmetic operators can handle. Either string number can be a valid number or a string number."
		},
		"SEEK": {
			"prefix": "SEEK",
			"body": [
				"SEEK $filevar, $offset, $relto THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the SEEK statement to move the file pointer by an offset specified in bytes, relative to the current position, the beginning of the file, or the end of the file."
		},
		"SEEK(ARG.)": {
			"prefix": "SEEK(ARG.)",
			"body": [
				"SEEK(ARG. $argnum) THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the SEEK(ARG.) statement to move the command line argument pointer to the next command line argument from left to right, or to a command line argument specified by arg#. The command line is delimited by blanks, and the first argument is assumed to be the first word after the program name. When a cataloged program is invoked, the argument list starts with the second word in the command line."
		},
		"SELECTE": {
			"prefix": "SELECTE",
			"body": "SELECTE TO $listname",
			"description": "Use the SELECTE statement to assign the contents of select list 0 to list.variable. list.variable is activated in place of select list 0 and can be read with the READNEXT statement."
		},
		"SELECTINDEX": {
			"prefix": "SELECTINDEX",
			"body": "SELECTINDEX $indexname, $val FROM $filevar TO $listno",
			"description": "Use the SELECTINDEX statement to create select lists from secondary indexes."
		},
		"SELECTINFO": {
			"prefix": "SELECTINFO",
			"body": "SELECTINFO($list, $key)",
			"description": "Use the SELECTINFO function to determine whether a select list is active, or to determine the number of items it contains."
		},
		"SEND": {
			"prefix": "SEND",
			"body": [
				"SEND $output TO $filevar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the SEND statement to write a block of data to a device. The SEND statement can be used to write data to a device that has been opened for I\/O using the OPENDEV statement or OPENSEQ statement."
		},
		"SENTENCE": {
			"prefix": "SENTENCE",
			"body": "SENTENCE()",
			"description": "Use the SENTENCE function to return the stored sentence that invoked the current process. Although the SENTENCE function uses no arguments, parentheses are required to identify it as a function. The SENTENCE function is a synonym for the @SENTENCE system variable."
		},
		"SEQ": {
			"prefix": "SEQ",
			"body": "SEQ($char)",
			"description": "Use the SEQ function to convert an ASCII character to its numeric string equivalent."
		},
		"SEQS": {
			"prefix": "SEQS",
			"body": "SEQS($DynArr)",
			"description": "Use the SEQS function to convert a dynamic array of ASCII characters to their numeric string equivalents."
		},
		"setAuthenticationDepth": {
			"prefix": "setAuthenticationDepth",
			"body": "setAuthenticationDepth($context, $depth, $ServerOrClient)",
			"description": "The setAuthenticationDepth() function sets how deeply UniData and UniVerse should verify before deciding that a certificate is not valid."
		},
		"setCipherSuite": {
			"prefix": "setCipherSuite",
			"body": "setCipherSuite($context, $cipherSpecs)",
			"description": "The setCipherSuite() function allows you to identify which cipher suites should be supported for the specified context. It affects the cipher suites and public key algorithms supported during the SSL\/ TLS handshake and subsequent data exchanges."
		},
		"setClientAuthentication": {
			"prefix": "setClientAuthentication",
			"body": "setClientAuthentication($context, $option)",
			"description": "The setClientAuthentication() function turns on or off client authentication for a server socket."
		},
		"setIpv": {
			"prefix": "setIpv",
			"body": "setIpv($option, $sockettype)",
			"description": "Use the setIpv function to set the default IPv connection for the whole system or for only Socket networks or UVNet. The function also returns the setting back for display."
		},
		"setPrivateKey": {
			"prefix": "setPrivateKey",
			"body": "setPrivateKey($key, $format, $keyLoc, $passPhrase, $validate, $context, $p12pass)",
			"description": "The setPrivateKey() function loads the private key into a security context so that it can be used by SSL functions. If the context already had a set private key, it will be replaced."
		},
		"setRandomSeed": {
			"prefix": "setRandomSeed",
			"body": "setRandomSeed($inFiles, $outFile, $length, $context)",
			"description": "The setRandomSeed() function generates a random seed file from a series of source files and sets that file as the default seed file for the supplied security context."
		},
		"setHTTPDefault": {
			"prefix": "setHTTPDefault",
			"body": "setHTTPDefault($opt, $val)",
			"description": "The setHTTPDefault function configures the default HTTP settings, including proxy server and port, buffer size, authentication credential, HTTP version, and request header values. These settings are used with every HTTP request that follows."
		},
		"setRequestHeader": {
			"prefix": "setRequestHeader",
			"body": "setRequestHeader($request_handle, $header_name, $header_value)",
			"description": "The setRequestHeader function enables you to set additional headers for a request."
		},
		"SETLOCALE": {
			"prefix": "SETLOCALE",
			"body": "SETLOCALE($category, $val)",
			"description": "In NLS mode, use the SETLOCALE function to enable or disable a locale for a specified category or change its setting."
		},
		"SETREM": {
			"prefix": "SETREM",
			"body": "SETREM $pos ON $dynarr",
			"description": "Use the SETREM statement to set the remove pointer in dynamic.array to the position specified by position."
		},
		"setSocketMap": {
			"prefix": "setSocketMap",
			"body": "setSocketMap($mapname)",
			"description": "The setSocketMap() function sets the default NLS map for either server or client sockets. If you call openSocket() or acceptConnection() prior to calling setSocketMap(), UniVerse uses the default map defined in uvconfig."
		},
		"setSocketOptions": {
			"prefix": "setSocketOptions",
			"body": "setSocketOptions($socket_handle, $options)",
			"description": "The setSocketOptions() function sets the current value for a socket option associated with a socket of any type."
		},
		"showSecurityContext": {
			"prefix": "showSecurityContext",
			"body": "showSecurityContext($context, $config)",
			"description": "The showSecurityContext() function dumps the SSL configuration parameters of a security context into a readable format."
		},
		"SIGNATURE": {
			"prefix": "SIGNATURE",
			"body": "SIGNATURE($algorithm, $action, $data, $dataLoc, $key, $keyLoc, $keyFmt, $pass, $sigIn, $result, $p12pass)",
			"description": "The SIGNATURE() function generates a digital signature or verifies a signature using the supplied key. Digital signature is generally created over a piece of data or document by some cryptographic algorithm and used to prove the authenticity and integrity of the data or document, for example, the recipient of the data with a valid digital signature has reason to believe that the data is from a trusted sender and its contents are not modified."
		},
		"SIN": {
			"prefix": "SIN",
			"body": "SIN($expr)",
			"description": "Use the SIN function to return the trigonometric sine of an expression. expression represents the angle expressed in degrees. Numbers greater than 1E17 produce a warning message, and 0 is returned. If expression evaluates to the null value, null is returned."
		},
		"SINH": {
			"prefix": "SINH",
			"body": "SINH($expr)",
			"description": "Use the SINH function to return the hyperbolic sine of expression. expression must be numeric and represents the angle expressed in degrees. If expression evaluates to the null value, null is returned."
		},
		"SLEEP": {
			"prefix": "SLEEP",
			"body": "SLEEP $seconds",
			"description": "Use the SLEEP statement to suspend execution of a BASIC program, pausing for a specified number of seconds."
		},
		"SMUL": {
			"prefix": "SMUL",
			"body": "SMUL($1, $2)",
			"description": "Use the SMUL function to multiply two string numbers and return the result as a string number. You can use this function in any expression where a string or string number is valid, but not necessarily where a standard number is valid, because string numbers can exceed the range of numbers that standard arithmetic operators can handle."
		},
		"SOAPCreateRequest": {
			"prefix": "SOAPCreateRequest",
			"body": "SOAPCreateRequest($URL, $soapAction, $Request)",
			"description": "The SOAPCreateRequest function creates a SOAP request and returns a handle to the request."
		},
		"SOAPCreateSecureRequest": {
			"prefix": "SOAPCreateSecureRequest",
			"body": "SOAPCreateSecureRequest($URL, $soapAction, $Request, $security_context)",
			"description": "The SOAPCreateSecureRequest function creates a secure SOAP request and returns a handle to the request."
		},
		"SOAPGetDefault": {
			"prefix": "SOAPGetDefault",
			"body": "SOAPGetDefault($opt, $val)",
			"description": "The SOAPGetDefault function retrieves default SOAP settings, such as the SOAP version."
		},
		"SOAPGetFault": {
			"prefix": "SOAPGetFault",
			"body": "SOAPGetFault($respData, $soapFault)",
			"description": "If the SOAPSubmitRequest function receives a SOAP Fault, the SOAPGetFault function parses the response data from SOAPSubmitRequest into a dynamic array of SOAP Fault components."
		},
		"SOAPGetResponseHeader": {
			"prefix": "SOAPGetResponseHeader",
			"body": "SOAPGetResponseHeader($Request, $headerName, $headerValue)",
			"description": "The SOAPGetResponseHeader function gets a specific response header after issuing a SOAP request."
		},
		"SOAPSetRequestBody": {
			"prefix": "SOAPSetRequestBody",
			"body": "SOAPSetRequestBody($Request, $value)",
			"description": "The SOAPSetRequestBody function sets up a SOAP request body directly, as opposed to having it constructed via the SOAPSetParameters function. With this function, you can also attach multiple body blocks to the SOAP request."
		},
		"SOAPSetRequestContent": {
			"prefix": "SOAPSetRequestContent",
			"body": "SOAPSetRequestContent($Request, $reqDoc, $docTypeFlag)",
			"description": "The SOAPSetRequestContent function sets the entire SOAP request's content from an input string or from a file."
		},
		"SOAPSetRequestHeader": {
			"prefix": "SOAPSetRequestHeader",
			"body": "SOAPSetRequestHeader($Request, $value)",
			"description": "The SOAPSetRequestHeader function sets up a SOAP request header. By default, there is no SOAP header."
		},
		"SOAPRequestWrite": {
			"prefix": "SOAPRequestWrite",
			"body": "SOAPRequestWrite($Request, $reqDoc, $docTypeFlag)",
			"description": "The SOAPRequestWrite function outputs the SOAP request, in XML format, to a string or to a file."
		},
		"SOAPSetDefault": {
			"prefix": "SOAPSetDefault",
			"body": "SOAPSetDefault($opt, $val)",
			"description": "Use the SOAPSetDefault function to define default SOAP settings, such as the SOAP version. By default, the SOAP version is 1.1, although you can specify version 1.2."
		},
		"SOAPSetParameters": {
			"prefix": "SOAPSetParameters",
			"body": "SOAPSetParameters($Request, $URI, $serviceName, $paramArray)",
			"description": "The SOAPSetParameters function sets up the SOAP request body, specifying a remote method to call along with the method's parameter list."
		},
		"SOAPSubmitRequest": {
			"prefix": "SOAPSubmitRequest",
			"body": "SOAPSubmitRequest($Request, $timeout, $respHeaders, $respData, $soapStatus)",
			"description": "The SOAPSubmitRequest function submits a request and gets the response."
		},
		"SOUNDEX": {
			"prefix": "SOUNDEX",
			"body": "SOUNDEX($str)",
			"description": "The SOUNDEX function evaluates expression and returns the most significant letter in the input string followed by a phonetic code. Non-alphabetic characters are ignored. If expression evaluates to the null value, null is returned."
		},
		"SPACE": {
			"prefix": "SPACE",
			"body": "SPACE($cnt)",
			"description": "Use the SPACE function to return a string composed of blank spaces. expression specifies the number of spaces in the string. If expression evaluates to the null value, the SPACE function fails and the program terminates with a run-time error message."
		},
		"SPACES": {
			"prefix": "SPACES",
			"body": "SPACES($DynArr)",
			"description": "Use the SPACES function to return a dynamic array with elements composed of blank spaces. dynamic.array specifies the number of spaces in each element. If dynamic.array or any element of dynamic.array evaluates to the null value, the SPACES function fails and the program terminates with a run-time error message."
		},
		"SPLICE": {
			"prefix": "SPLICE",
			"body": "SPLICE($array1, $str, $array2)",
			"description": "Use the SPLICE function to create a dynamic array of the element-by-element concatenation of two dynamic arrays, separating concatenated elements by the value of expression."
		},
		"SQRT": {
			"prefix": "SQRT",
			"body": "SQRT($expression)",
			"description": "Use the SQRT function to return the square root of expression. expression must evaluate to a numeric value that is greater than or equal to 0. If expression evaluates to a negative value, the result of the function is SQRT(-n) and an error message is printed. If expression evaluates to the null value, null is returned."
		},
		"SSELECT": {
			"prefix": "SSELECT",
			"body": "SSELECT $filevar TO $list ON ERROR $statements",
			"description": "Use an SSELECT statement to create: 1) A numbered select list of record IDs in sorted order from a UniVerse file 2) A numbered select list of record IDs from a dynamic array. A select list of record IDs from a dynamic array is not in sorted order."
		},
		"SSUB": {
			"prefix": "SSUB",
			"body": "SSUB($1, $2)",
			"description": "Use the SSUB function to subtract string.number.2 from string.number.1 and return the result as a string number. You can use this function in any expression where a string or string number is valid, but not necessarily where a standard number is valid, because string numbers can exceed the range of numbers that standard arithmetic operators can handle."
		},
		"STATUS Function": {
			"prefix": "STATUS",
			"body": "STATUS()",
			"description": "Use the STATUS function to determine the results of the operations performed by certain statements and functions."
		},
		"STATUS Statement": {
			"prefix": "STATUS",
			"body": [
				"STATUS $array FROM $variable THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the STATUS statement to determine the status of an open file. The STATUS statement returns the file status as a dynamic array and assigns it to dynamic.array."
		},
		"STR": {
			"prefix": "STR",
			"body": "STR($str, $cnt)",
			"description": "Use the STR function to produce a specified number of repetitions of a particular character string."
		},
		"STRS": {
			"prefix": "STRS",
			"body": "STRS($DynArr, $count)",
			"description": "Use the STRS function to produce a dynamic array containing the specified number of repetitions of each element of dynamic.array."
		},
		"submitRequest": {
			"prefix": "submitRequest",
			"body": "submitRequest($request_handle, $time_out, $post_data, $response_headers, $response_data, $http_status)",
			"description": "The submitRequest function will submit a request and get a response."
		},
		"SUBR": {
			"prefix": "SUBR",
			"body": "SUBR($name, $args)",
			"description": "Use the SUBR function to return the value of an external subroutine. The SUBR function is commonly used in I-descriptors."
		},
		"SUBROUTINE Skeleton": {
			"prefix": "SUB",
			"body": [
				"SUBROUTINE $1($2)",
				"*-----",
				"* Description : $3",
				"* Author  : $4",
				"* Date: $5",
				"*-----",
				" \\$INCLUDE Common",
				"*-----",
				" Gosub Initialise",
				"*-----",
				"  $6",
				"*-----",
				"ExitProgram:",
				"*-----",
				" Return",
				" End",
				"*-----",
				"Initialise:",
				"*-----",
				"",
				" Return"
			],
			"description": "Standard Subroutine Skeleton"
		},
		"SUBS": {
			"prefix": "SUBS",
			"body": "SUBS($DynArr1, $DynArr2)",
			"description": "Use the SUBS function to create a dynamic array of the element-by-element subtraction of two dynamic arrays."
		},
		"SUBSTRINGS": {
			"prefix": "SUBSTRINGS",
			"body": "SUBSTRINGS($DynArr, $start, $length)",
			"description": "Use the SUBSTRINGS function to create a dynamic array each of whose elements are substrings of the corresponding elements of dynamic.array."
		},
		"SUM": {
			"prefix": "SUM",
			"body": "SUM($DynArr)",
			"description": "Use the SUM function to calculate the sum of numeric data. Only elements at the lowest delimiter level of a dynamic array are summed. The total is returned as a single element at the next highest delimiter level."
		},
		"SUMMATION": {
			"prefix": "SUMMATION",
			"body": "SUMMATION($dynarr)",
			"description": "Use the SUMMATION function to return the sum of all the elements in dynamic.array. Nonnumeric values, except the null value, are treated as 0."
		},
		"SWAP": {
			"prefix": "SWAP",
			"body": "SWAP $var1 $var2",
			"description": "The SWAP statement interchanges the values in the variables you specify. variable can be any valid variable, for example, integers, numbers, characters, and so forth."
		},
		"SYSTEM": {
			"prefix": "SYSTEM",
			"body": "SYSTEM($key)",
			"description": "Use the SYSTEM function to check on the status of a system function. Use the SYSTEM function to test whether NLS is on when you run a program, and to display information about NLS settings."
		},
		"TABSTOP": {
			"prefix": "TABSTOP",
			"body": "TABSTOP $expr",
			"description": "Use the TABSTOP statement to set the current tabstop width for PRINT statement. The initial tabstop setting is 10."
		},
		"TAN": {
			"prefix": "TAN",
			"body": "TAN($expression)",
			"description": "Use the TAN function to return the trigonometric tangent of expression. expression represents an angle expressed in degrees."
		},
		"TANH": {
			"prefix": "TANH",
			"body": "TANH($expr)",
			"description": "Use the TANH function to return the hyperbolic tangent of expression. expression must be numeric and represents the angle expressed in degrees. If expression evaluates to the null value, null is returned."
		},
		"TERMINFO": {
			"prefix": "TERMINFO",
			"body": "TERMINFO($arg)",
			"description": "Use the TERMINFO function to access the device-independent terminal handler string defined for the current terminal type. The TERMINFO function returns a dynamic array containing the terminal characteristics for the terminal type set by TERM or SET.TERM.TYPE."
		},
		"TIME": {
			"prefix": "TIME",
			"body": "TIME()",
			"description": "Use the TIME function to return a string value expressing the internal time of day. The internal time is the number of seconds that have passed since midnight to the nearest thousandth of a second (local time)."
		},
		"TIMEDATE": {
			"prefix": "TIMEDATE",
			"body": "TIMEDATE()",
			"description": "Use the TIMEDATE function to return the current system time and date in format: hh:mm:ss dd mmm yyyy."
		},
		"TIMEOUT": {
			"prefix": "TIMEOUT",
			"body": "TIMEOUT $filevar, $time",
			"description": "Use the TIMEOUT statement to terminate a READSEQ statement or READBLK statement if no data is read in the specified time. You can also use the TIMEOUT statement to set a time limit for a UVNet link. Use the TTYGET and TTYSET statements to set a timeout value for a file open on a serial communications port."
		},
		"TPARM": {
			"prefix": "TPARM",
			"body": "TPARM($terminfo, $args)",
			"description": "Use the TPARM function to evaluate a parameterized terminfo string."
		},
		"TPRINT": {
			"prefix": "TPRINT",
			"body": "TPRINT $printlist",
			"description": "Use the TPRINT statement to send data to the screen, a line printer, or another print file. TPRINT is similar to the PRINT statement, except that TPRINT lets you specify time delay expressions in the print list."
		},
		"TRANS": {
			"prefix": "TRANS",
			"body": "TRANS($filename, $key, $field, $controlcode)",
			"description": "Use the TRANS function to return the contents of a field or a record in a UniVerse file. TRANS opens the file, reads the record, and extracts the specified data."
		},
		"TRANSACTION ABORT": {
			"prefix": "TRANSACTION ABORT",
			"body": "TRANSACTION ABORT",
			"description": "Use the TRANSACTION ABORT statement to cancel all file I\/O changes made during a transaction."
		},
		"TRANSACTION COMMIT": {
			"prefix": "TRANSACTION COMMIT",
			"body": [
				"TRANSACTION COMMIT THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the TRANSACTION COMMIT statement to commit all file I\/O changes made during a transaction."
		},
		"TRANSACTION START": {
			"prefix": "TRANSACTION START",
			"body": [
				"TRANSACTION START THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the TRANSACTION START statement to begin a new transaction."
		},
		"TRIMB": {
			"prefix": "TRIMB",
			"body": "TRIMB($str)",
			"description": "Use the TRIMB function to remove all trailing spaces and tabs from expression. All other spaces or tabs in expression are left intact. If expression evaluates to the null value, null is returned."
		},
		"TRIMBS": {
			"prefix": "TRIMBS",
			"body": "TRIMBS($DynArr)",
			"description": "Use the TRIMBS function to remove all trailing spaces and tabs from each element of dynamic.array, and to reduce multiple occurrences of spaces and tabs to a single space."
		},
		"TRIMFS": {
			"prefix": "TRIMFS",
			"body": "TRIMFS($DynArr)",
			"description": "Use the TRIMFS function to remove all leading spaces and tabs from each element of dynamic.array, and to reduce multiple occurrences of spaces and tabs to a single space."
		},
		"TRIMS": {
			"prefix": "TRIMS",
			"body": "TRIMS($dynarr)",
			"description": "Use the TRIMS function to remove unwanted spaces and tabs from each element of dynamic.array, and to reduce multiple occurrences of spaces and tabs to a single space."
		},
		"TRUNC": {
			"prefix": "TRUNC",
			"body": "TRUNC($number, $places)",
			"description": "Use the TRUNC function to truncate a numeric variable or string to a specified number of decimal places."
		},
		"UDOArrayAppendItem": {
			"prefix": "UDOArrayAppendItem",
			"body": "UDOArrayAppendItem($udoHandle, $value)",
			"description": "The UDOArrayAppendItem() function appends the item you specify to the UDO array."
		},
		"UDOArrayDeleteItem": {
			"prefix": "UDOArrayDeleteItem",
			"body": "UDOArrayDeleteItem($udoHandle, $index)",
			"description": "The UDOArrayDeleteItem() function deletes the array item you specify by its index."
		},
		"UDOArrayGetItem": {
			"prefix": "UDOArrayGetItem",
			"body": "UDOArrayGetItem($udoHandle, $index, $value, $value_type)",
			"description": "The UDOArrayGetItem() function returns a UDO array item by its index."
		},
		"UDOArrayGetNextItem": {
			"prefix": "UDOArrayGetNextItem",
			"body": "UDOArrayGetNextItem($udoHandle, $value, $type)",
			"description": "The UDOArrayGetNextItem() function returns the next UDO array item relative to the current position, which is the position of the array the last time it was accessed by this function. The initial position is 1."
		},
		"UDOArrayGetSize": {
			"prefix": "UDOArrayGetSize",
			"body": "UDOArrayGetSize($udoHandle, $size)",
			"description": "The UDOArrayGetSize() function gets the size of a UDO array."
		},
		"UDOArrayInsertItem": {
			"prefix": "UDOArrayInsertItem",
			"body": "UDOArrayInsertItem($udoHandle, $index, $value)",
			"description": "The UDOArrayInsertItem() function inserts a UDO array element at the position you specify by index."
		},
		"UDOArraySetItem": {
			"prefix": "UDOArraySetItem",
			"body": "UDOArraySetItem($udoHandle, $index, $value)",
			"description": "The UDOArraySetItem() function sets or inserts a UDO array element at the position you specify."
		},
		"UDOClone": {
			"prefix": "UDOClone",
			"body": "UDOClone($udoHandle, $newUdoHandle)",
			"description": "The UDOClone function clones a UDO object or array so that changes to the new object or array will not affect the original object."
		},
		"UDOCreate": {
			"prefix": "UDOCreate",
			"body": "UDOCreate($udoType, $udoHandle)",
			"description": "The UDOCreate function creates a UDO item of the type you specify."
		},
		"UDODeleteProperty": {
			"prefix": "UDODeleteProperty",
			"body": "UDODeleteProperty($udoHandle, $name)",
			"description": "The UDODeleteProperty function deletes a property from the UDO object."
		},
		"UDOFree": {
			"prefix": "UDOFree",
			"body": "UDOFree($udoHandle)",
			"description": "The UDOFree function forcefully removes a UDO object or array from memory."
		},
		"UDOGetLastError": {
			"prefix": "UDOGetLastError",
			"body": "UDOGetLastError($errorCode, $errorMessage)",
			"description": "If the previous UDO call returned UDO_ERROR, use the UDOGetLastError() function to return the error code and error message."
		},
		"UDOGetNextProperty": {
			"prefix": "UDOGetNextProperty",
			"body": "UDOGetNextProperty($udoHandle, $name, $value, $value_type)",
			"description": "The UDOGetNextProperty function provides a convenient way to walk through all the properties in a UDO object, without needing to know the property names in advance."
		},
		"UDOGetOption": {
			"prefix": "UDOGetOption",
			"body": "UDOGetOption($option, $value)",
			"description": "The UDOGetOption function gets the value of a UDO option."
		},
		"UDOGetProperty": {
			"prefix": "UDOGetProperty",
			"body": "UDOGetProperty($udoHandle, $name, $value, $value_type)",
			"description": "The UDOGetProperty function returns the value and type of property on the UDO object."
		},
		"UDOGetPropertyNames": {
			"prefix": "UDOGetPropertyNames",
			"body": "UDOGetPropertyNames($udoHandle, $udoArray)",
			"description": "The UDOGetPropertyNames function returns a UDO array that holds the names of all the properties in the UDO object."
		},
		"UDOGetType": {
			"prefix": "UDOGetType",
			"body": "UDOGetType($udoHandle, $type)",
			"description": "The UDOGetType() function gets the UDO value type of a UniVerse BASIC variable."
		},
		"UDOIsTypeOf": {
			"prefix": "UDOIsTypeOf",
			"body": "UDOIsTypeOf($udoHandle, $type)",
			"description": "The UDOIsTypeOf() function tests the UDO value type of a UniVerse BASIC variable."
		},
		"UDORead": {
			"prefix": "UDORead",
			"body": "UDORead($inputString, $inputType, $udoHandle)",
			"description": "The UDORead function creates a UDO object from a JSON string or XMLstring."
		},
		"UDOSetOption": {
			"prefix": "UDOSetOption",
			"body": "UDOSetOption($option, $value)",
			"description": "The UDOSetOption function sets the options for the UDO API."
		},
		"UDOSetProperty": {
			"prefix": "UDOSetProperty",
			"body": "UDOSetProperty($udoHandle, $name, $value)",
			"description": "The UDOSetProperty function creates or updates a property on a UDO object."
		},
		"UDOWrite": {
			"prefix": "UDOWrite",
			"body": "UDOWrite($udoHandle, $outputType, $outputString)",
			"description": "Writes a UDO object in JSON or XML format."
		},
		"UNICHAR": {
			"prefix": "UNICHAR",
			"body": "UNICHAR($unicode)",
			"description": "Use the UNICHAR function to generate a single character from a Unicode value."
		},
		"UNICHARS": {
			"prefix": "UNICHARS",
			"body": "UNICHARS($dynarr)",
			"description": "Use the UNICHARS function to generate a dynamic array of characters from a dynamic array of Unicode values."
		},
		"UNISEQ": {
			"prefix": "UNISEQ",
			"body": "UNISEQ($expr)",
			"description": "Use the UNISEQ function to generate a Unicode value from expression."
		},
		"UNISEQS": {
			"prefix": "UNISEQS",
			"body": "UNISEQS($dynarr)",
			"description": "Use the UNISEQS function to generate an array of Unicode values from a dynamic array of characters."
		},
		"UNLOCK": {
			"prefix": "UNLOCK",
			"body": "UNLOCK $expr",
			"description": "Use the UNLOCK statement to release a process lock set by the LOCK statement."
		},
		"UPRINT": {
			"prefix": "UPRINT",
			"body": "UPRINT $expr",
			"description": "In NLS mode, use the UPRINT statement to print data that was mapped to an external format using OCONV mapname. The UPRINT statement subsequently sends the mapped data to the screen, a line printer, or another print file with no further mapping."
		},
		"USERINFO": {
			"prefix": "USERINFO",
			"body": "USERINFO($code, $value, $userinfo)",
			"description": "Use the USERINFO function to get the pid, user number, and more for the pid or user number specified."
		},
		"uvsysmon": {
			"prefix": "uvsysmon",
			"body": "uvsysmon",
			"description": "The system-level uvsysmon utility monitors the performance of the Recoverable File System (RFS)."
		},
		"WEOF": {
			"prefix": "WEOF",
			"body": [
				"WEOF $UNIT THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the WEOF statement to write an end-of-file (EOF) mark to tape."
		},
		"WEOFSEQ": {
			"prefix": "WEOFSEQ",
			"body": "WEOFSEQ $filevar ON ERROR $err_statements",
			"description": "Use the WEOFSEQ statement to write an end-of-file (EOF) mark in a file opened for sequential access. The end-of-file mark is written at the current position and has the effect of truncating the file at this point. Any subsequent READSEQ statement has its ELSE statements executed."
		},
		"WRITEBLK": {
			"prefix": "WRITEBLK",
			"body": [
				"WRITEBLK $var ON $filevar THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the WRITEBLK statement to write a block of data to a file opened for sequential processing. Each WRITEBLK statement writes the value of expression starting at the current position in the file. The current position is incremented to beyond the last byte written. WRITEBLK does not add a newline at the end of the data."
		},
		"WRITELIST": {
			"prefix": "WRITELIST",
			"body": "WRITELIST $dynarr TO $listname",
			"description": "Use the WRITELIST statement to save a list as a record in the &SAVEDLISTS& file."
		},
		"WRITESEQ": {
			"prefix": "WRITESEQ",
			"body": [
				"WRITESEQ $expr TO $filevar ON ERROR $err_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the WRITESEQ statement to write new lines to a file opened for sequential processing. UniVerse keeps a pointer to the current position in the file while it is open for sequential processing. The OPENSEQ statement sets this pointer to the first byte of the file, and it is advanced by the READSEQ statement, READBLK statement, WRITESEQ, and WRITEBLK statement."
		},
		"WRITESEQF": {
			"prefix": "WRITESEQF",
			"body": [
				"WRITESEQF $var TO $filevar ON ERROR $err_statements THEN",
				"\t$then_statements",
				"END ELSE",
				"\t$else_statements",
				"END"
			],
			"description": "Use the WRITESEQF statement to write new lines to a file opened for sequential processing, and to ensure that data is physically written to disk (that is, not buffered) before the next statement in the program is executed. The sequential file must be open, and the end-of-file marker must be reached before you can write to the file. You can use the FILEINFO function to determine the number of the line about to be written."
		},
		"writeSocket": {
			"prefix": "writeSocket",
			"body": "writeSocket($socket_handle, $socket_data, $time_out, $mode, $actual_write_size)",
			"description": "Use the writeSocket() function to write data to a socket connection."
		},
		"WRITEVU": {
			"prefix": "WRITEVU",
			"body": "WRITEVU $var TO $filevar,$recordkey,$attr",
			"description": "Use the WRITEVU statement to maintain an update record lock while writing on the contents of a specified field of a record of a UniVerse file."
		},
		"XDOMAddChild": {
			"prefix": "XDOMAddChild",
			"body": "XDOMAddChild($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag, $nodeType)",
			"description": "Finds the xpathString in the context xmlHandle in the DOM structure, and inserts a node as the last child of the found node. If the inserted node type is XDOM.ATTR.NODE, this node is inserted as an attribute."
		},
		"XDOMAppend": {
			"prefix": "XDOMAppend",
			"body": "XDOMAppend($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag)",
			"description": "Finds the xpathString in the context xmlHandle in the DOM structure, and inserts nodeHandle into the DOM structure as the next sibling of the found node. If the inserted node type is XDOM.ATTR.NODE, this node is inserted as an attribute."
		},
		"XDOMClone": {
			"prefix": "XDOMClone",
			"body": "XDOMClone($xmlHandle, $newXmlHandle, $depth)",
			"description": "The XDOMClone function duplicates the DOM subtree specified by xmlHandle to a new subtree newXmlHandle. The duplicate node has no parent (parentNode returns null.)."
		},
		"XDOMClose": {
			"prefix": "XDOMClose",
			"body": "XDOMClose($domHandle)",
			"description": "The XDOMClose function frees the DOM structure."
		},
		"XDOMCreateNode": {
			"prefix": "XDOMCreateNode",
			"body": "XDOMCreateNode($xmlHandle, $nodeName, $nodeValue, $nodeType, $nodeHandle)",
			"description": "XDOMCreateNode creates a new node in the DOM structure."
		},
		"XDOMCreateRoot": {
			"prefix": "XDOMCreateRoot",
			"body": "XDOMCreateRoot($domHandle)",
			"description": "The XDOMCreateRoot function creates a new DOM structure with root only. You can use the result handle in other functions where a DOM handle or node handle is needed."
		},
		"XDOMEvaluate": {
			"prefix": "XDOMEvaluate",
			"body": "XDOMEvaluate($xmlHandle, $xpathString, $nsMap, $aValue)",
			"description": "XDOMEvaluate returns the value of xpathString in the context xmlHandle in the DOM structure."
		},
		"XDOMGetAttribute": {
			"prefix": "XDOMGetAttribute",
			"body": "XDOMGetAttribute($nodeHandle, $attrName, $nodeHandle)",
			"description": "XDOMGetAttribute gets the node's attribute node, whose attribute name is attrName."
		},
		"XDOMGetChildNodes": {
			"prefix": "XDOMGetChildNodes",
			"body": "XDOMGetChildNodes($xmlHandle, $nodeListHandle)",
			"description": "The XDOMGetChildNodes function returns all child nodes of xmlHandle."
		},
		"XDOMGetElementById": {
			"prefix": "XDOMGetElementById",
			"body": "XDOMGetElementById($xmlHandle, $idstr, $nodeHandle)",
			"description": "The XDOMGetElementById function finds the first element with the ID you specify."
		},
		"XDOMGetElementsByName": {
			"prefix": "XDOMGetElementsByName",
			"body": "XDOMGetElementsByName($xmlHandle, $namestr, $nodeListHandle)",
			"description": "The XDOMGetElementsByName function tries to find all elements with the name you specify."
		},
		"XDOMGetElementsByTag": {
			"prefix": "XDOMGetElementsByName($xmlHandle, $namestr, $nodeListHandle)",
			"body": "XDOMGetElementsByTag($xmlHandle, $tagname, $nodeListHandle)",
			"description": "The XDOMGetElementsByTag function tries to find all elements with the tag name you specify."
		},
		"XDOMGetNodeName": {
			"prefix": "XDOMGetNodeName",
			"body": "XDOMGetElementsByTag($nodeHandle, $nodeName)",
			"description": "XDOMGetNodeName returns the node name."
		},
		"XDOMGetNodeType": {
			"prefix": "XDOMGetNodeType",
			"body": "XDOMGetNodeType($nodeHandle, $nodeType)",
			"description": "The XDOMGetNodeType function returns the node type."
		},
		"XDOMGetNodeValue": {
			"prefix": "XDOMGetNodeValue",
			"body": "XDOMGetNodeValue($nodeHandle, $nodeValue)",
			"description": "XDOMGetNodeValue gets the node value."
		},
		"XDOMGetOwnerDocument": {
			"prefix": "XDOMGetOwnerDocument",
			"body": "XDOMGetOwnerDocument($nodeHandle, $domHandle)",
			"description": "The XDOMGetOwnerDocument function returns the DOM handle to which nodeHandle belongs."
		},
		"XDOMGetUserData": {
			"prefix": "XDOMGetUserData",
			"body": "XDOMGetUserData($nodeHandle, $userData)",
			"description": "The XDOMGetUserData function returns the user data associated with the node."
		},
		"XDOMItem": {
			"prefix": "XDOMItem",
			"body": "XDOMItem($nodeListHandle, $index, $dataHandle, $dataType)",
			"description": "The XDOMItem function returns the index-th item in the list."
		},
		"XDOMLength": {
			"prefix": "XDOMLength",
			"body": "XDOMLength($nodeListHandle, $length)",
			"description": "The XDOMLength function determines the number of nodes in the list. The range of the valid child node index is to 1 to length, inclusive."
		},
		"XDOMLocate": {
			"prefix": "XDOMLocate",
			"body": "XDOMLocate($xmlHandle, $xpathString, $nsMap, $nodeHandle, $XMLSINGLE_XMLMULTI)",
			"description": "XDOMLocate finds a starting point for relative XPath searching in context xmlHandle in the DOM structure. The xpathString should specify only one node; otherwise, this function will return an error."
		},
		"XDOMLocateNode": {
			"prefix": "XDOMLocateNode",
			"body": "XDOMLocateNode($nodeHandle, $direction, $childIndex, $nodeType, $newNodeHandle)",
			"description": "The XDOMLocateNode function traverses from nodeHandle and gets the next node according to direction and childIndex."
		},
		"XDOMOpen": {
			"prefix": "XDOMOpen",
			"body": "XDOMOpen($xmlDocument, $docLocation, $domHandle)",
			"description": "The XDOMOpen function reads an xmlDocument and creates DOM structure. If the DTD is included in the document, UniVerse validates the document. The xmlDocument can be from a string, or from a file, depending on the docLocation flag."
		},
		"XDOMQuery": {
			"prefix": "XDOMQuery",
			"body": "XDOMQuery($xmlHandle, $xquery, $xqueryLocation, $itemListHandle)",
			"description": "The XDOMQuery function runs xquery on the current document or document node you specify with xmlHandle."
		},
		"XDOMRemove": {
			"prefix": "XDOMRemove",
			"body": "XDOMRemove($xmlHandle, $xpathString, $nsMap, $attrName, $nodeHandle)",
			"description": "XDOMRemove finds the xpathString in the context xmlHandle in the DOM structure, and then removes the found node or its attribute with name attrName."
		},
		"XDOMReplace": {
			"prefix": "XDOMReplace",
			"body": "XDOMReplace($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag)",
			"description": "XDOMReplace finds the xpathString in the context xmlHandle in the DOM structure, and replaces the found node with nodeHandle."
		},
		"XDOMSetNodeValue": {
			"prefix": "XDOMSetNodeValue",
			"body": "XDOMSetNodeValue($nodeHandle, $nodeValue)",
			"description": "XDOMSetNodeValue sets the node value."
		},
		"XDOMSetUserData": {
			"prefix": "XDOMSetUserData",
			"body": "XDOMSetUserData($nodeHandle, $userData)",
			"description": "The XDOMSetUserData function sets the user data associated with the node."
		},
		"XDOMTransform": {
			"prefix": "XDOMTransform",
			"body": "XDOMTransform($domHandle, $styleSheet, $ssLocation, $outDomHandle)",
			"description": "The XDOMTransform function transforms input DOM structure using the style sheet specified by styleSheet to output DOM structure."
		},
		"XDOMValidate": {
			"prefix": "XDOMValidate",
			"body": "XDOMValidate($xmlDocument, $docLocation, $schFile, $schLocation)",
			"description": "The XDOMValidate function validates the DOM document using the schema specified by schFile."
		},
		"XDOMWrite": {
			"prefix": "XDOMWrite",
			"body": "XDOMWrite($domHandle, $xmlDocument, $docLocation)",
			"description": "The XDOMWrite function writes the DOM structure to xmlDocument. xmlDocument can be a string or a file, depending on the value of the docLocation flag."
		},
		"XLATE": {
			"prefix": "XLATE",
			"body": "XLATE($filename, $recordkey, $field, $actioncode)",
			"description": "Use the XLATE function to return the contents of a field or a record in a UniVerse file. XLATE opens the file, reads the record, and extracts the specified data."
		},
		"XMAPAppendRec": {
			"prefix": "XMAPAppendRec",
			"body": "XMAPAppendRec($XMAPhandle, $file_name, $record)",
			"description": "The XMAPAppendRec function formats the specified record from the UniVerseUniData file as a U2XMAP dataset record and appends it to the U2XMAP dataset."
		},
		"XMAPClose": {
			"prefix": "XMAPClose",
			"body": "XMAPClose($XMAP_handle)",
			"description": "The XMAPClose function closes the U2XMAP dataset handle and frees all related structures and memory."
		},
		"XMAPCreate": {
			"prefix": "XMAPCreate",
			"body": "XMAPCreate($u2xmapping_rules, $mapping_flag, $XMAPhandle)",
			"description": "The XMAPCreate function creates an empty XML document for transferring data from the UniVerse database to XML according the mapping rules you define."
		},
		"XMAPOpen": {
			"prefix": "XMAPOpen",
			"body": "XMAPOpen($xml_document, $doc_flag, $u2xmapping_rules, $u2xmap_flag, $XMAPhandle)",
			"description": "The XMAPOpen function opens an XML document as a U2XMAP data set."
		},
		"XMAPReadNext": {
			"prefix": "XMAPReadNext",
			"body": "XMAPReadNext($XMAPhandle, $file_name, $record)",
			"description": "The XMAPReadNext function retrieves the next record from the U2XMAP dataset and formats it as a record of the UniVerseUniData file that is being mapped."
		},
		"XMAPToXMLDoc": {
			"prefix": "XMAPToXMLDoc",
			"body": "XMAPToXMLDoc($XMAPhandle, $xmlfile, $doc_flag)",
			"description": "The XMAPToXMLDoc function generates an XML document from the data in the U2XMAP dataset using the mapping rules you define. The XML document can be either an XML DOM handle or an XML document. UniVerse writes the data to a file or a UniVerse BASIC variable."
		},
		"XMLError": {
			"prefix": "XMLError",
			"body": "XMLError($errmsg)",
			"description": "Use the XMLError function to get the last error message."
		},
		"XMLExecute": {
			"prefix": "XMLExecute",
			"body": "XMLExecute($cmd, $options, $xmlvar, $xsdvar)",
			"description": "The XMLExecute function enables you to create an XML document using the RetrieVe LIST statement or the UniVerse SQL SELECT statement from a UniVerse BASIC program."
		},
		"XMLGetError": {
			"prefix": "XMLGetError",
			"body": "XMLGetError($errorCode, $errorMessage)",
			"description": "The XMLGetError function returns the error code and error message after the previous XML API failed."
		},
		"XTD": {
			"prefix": "XTD",
			"body": "XTD($str)",
			"description": "Use the XTD function to convert a string of hexadecimal characters to an integer. If string evaluates to the null value, null is returned."
		}
	}
}